{"ast":null,"code":"/*!\n * @pixi/prepare - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { settings } from '@pixi/settings';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\n\nsettings.UPLOADS_PER_FRAME = 4;\n/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @class\n * @memberof PIXI\n */\n\nvar CountLimiter = function CountLimiter(maxItemsPerFrame) {\n  /**\n   * The maximum number of items that can be prepared each frame.\n   * @type {number}\n   * @private\n   */\n  this.maxItemsPerFrame = maxItemsPerFrame;\n  /**\n   * The number of items that can be prepared in the current frame.\n   * @type {number}\n   * @private\n   */\n\n  this.itemsLeft = 0;\n};\n/**\n * Resets any counting properties to start fresh on a new frame.\n */\n\n\nCountLimiter.prototype.beginFrame = function beginFrame() {\n  this.itemsLeft = this.maxItemsPerFrame;\n};\n/**\n * Checks to see if another item can be uploaded. This should only be called once per item.\n * @return {boolean} If the item is allowed to be uploaded.\n */\n\n\nCountLimiter.prototype.allowedToUpload = function allowedToUpload() {\n  return this.itemsLeft-- > 0;\n};\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\n\n\nvar BasePrepare = function BasePrepare(renderer) {\n  var this$1 = this;\n  /**\n   * The limiter to be used to control how quickly items are prepared.\n   * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n   */\n\n  this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n  /**\n   * Reference to the renderer.\n   * @type {PIXI.AbstractRenderer}\n   * @protected\n   */\n\n  this.renderer = renderer;\n  /**\n   * The only real difference between CanvasPrepare and Prepare is what they pass\n   * to upload hooks. That different parameter is stored here.\n   * @type {object}\n   * @protected\n   */\n\n  this.uploadHookHelper = null;\n  /**\n   * Collection of items to uploads at once.\n   * @type {Array<*>}\n   * @private\n   */\n\n  this.queue = [];\n  /**\n   * Collection of additional hooks for finding assets.\n   * @type {Array<Function>}\n   * @private\n   */\n\n  this.addHooks = [];\n  /**\n   * Collection of additional hooks for processing assets.\n   * @type {Array<Function>}\n   * @private\n   */\n\n  this.uploadHooks = [];\n  /**\n   * Callback to call after completed.\n   * @type {Array<Function>}\n   * @private\n   */\n\n  this.completes = [];\n  /**\n   * If prepare is ticking (running).\n   * @type {boolean}\n   * @private\n   */\n\n  this.ticking = false;\n  /**\n   * 'bound' call for prepareItems().\n   * @type {Function}\n   * @private\n   */\n\n  this.delayedTick = function () {\n    // unlikely, but in case we were destroyed between tick() and delayedTick()\n    if (!this$1.queue) {\n      return;\n    }\n\n    this$1.prepareItems();\n  }; // hooks to find the correct texture\n\n\n  this.registerFindHook(findText);\n  this.registerFindHook(findTextStyle);\n  this.registerFindHook(findMultipleBaseTextures);\n  this.registerFindHook(findBaseTexture);\n  this.registerFindHook(findTexture); // upload hooks\n\n  this.registerUploadHook(drawText);\n  this.registerUploadHook(calculateTextStyle);\n};\n/**\n * Upload all the textures and graphics to the GPU.\n *\n * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n *    Either the container or display object to search for items to upload, the items to upload themselves,\n *    or the callback function, if items have been added using `prepare.add`.\n * @param {Function} [done] - Optional callback when all queued uploads have completed\n */\n\n\nBasePrepare.prototype.upload = function upload(item, done) {\n  if (typeof item === 'function') {\n    done = item;\n    item = null;\n  } // If a display object, search for items\n  // that we could upload\n\n\n  if (item) {\n    this.add(item);\n  } // Get the items for upload from the display\n\n\n  if (this.queue.length) {\n    if (done) {\n      this.completes.push(done);\n    }\n\n    if (!this.ticking) {\n      this.ticking = true;\n      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n    }\n  } else if (done) {\n    done();\n  }\n};\n/**\n * Handle tick update\n *\n * @private\n */\n\n\nBasePrepare.prototype.tick = function tick() {\n  setTimeout(this.delayedTick, 0);\n};\n/**\n * Actually prepare items. This is handled outside of the tick because it will take a while\n * and we do NOT want to block the current animation frame from rendering.\n *\n * @private\n */\n\n\nBasePrepare.prototype.prepareItems = function prepareItems() {\n  this.limiter.beginFrame(); // Upload the graphics\n\n  while (this.queue.length && this.limiter.allowedToUpload()) {\n    var item = this.queue[0];\n    var uploaded = false;\n\n    if (item && !item._destroyed) {\n      for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n        if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n          this.queue.shift();\n          uploaded = true;\n          break;\n        }\n      }\n    }\n\n    if (!uploaded) {\n      this.queue.shift();\n    }\n  } // We're finished\n\n\n  if (!this.queue.length) {\n    this.ticking = false;\n    var completes = this.completes.slice(0);\n    this.completes.length = 0;\n\n    for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++) {\n      completes[i$1]();\n    }\n  } else {\n    // if we are not finished, on the next rAF do this again\n    Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n  }\n};\n/**\n * Adds hooks for finding items.\n *\n * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n *      function must return `true` if it was able to add item to the queue.\n * @return {this} Instance of plugin for chaining.\n */\n\n\nBasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {\n  if (addHook) {\n    this.addHooks.push(addHook);\n  }\n\n  return this;\n};\n/**\n * Adds hooks for uploading items.\n *\n * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n *      function must return `true` if it was able to handle upload of item.\n * @return {this} Instance of plugin for chaining.\n */\n\n\nBasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {\n  if (uploadHook) {\n    this.uploadHooks.push(uploadHook);\n  }\n\n  return this;\n};\n/**\n * Manually add an item to the uploading queue.\n *\n * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n *    add to the queue\n * @return {this} Instance of plugin for chaining.\n */\n\n\nBasePrepare.prototype.add = function add(item) {\n  // Add additional hooks for finding elements on special\n  // types of objects that\n  for (var i = 0, len = this.addHooks.length; i < len; i++) {\n    if (this.addHooks[i](item, this.queue)) {\n      break;\n    }\n  } // Get children recursively\n\n\n  if (item instanceof Container) {\n    for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) {\n      this.add(item.children[i$1]);\n    }\n  }\n\n  return this;\n};\n/**\n * Destroys the plugin, don't use after this.\n *\n */\n\n\nBasePrepare.prototype.destroy = function destroy() {\n  if (this.ticking) {\n    Ticker.system.remove(this.tick, this);\n  }\n\n  this.ticking = false;\n  this.addHooks = null;\n  this.uploadHooks = null;\n  this.renderer = null;\n  this.completes = null;\n  this.queue = null;\n  this.limiter = null;\n  this.uploadHookHelper = null;\n};\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false; // Objects with multiple textures\n\n  if (item && item._textures && item._textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param {PIXI.Texture} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof BaseTexture) {\n    var texture = item.baseTexture;\n\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof Texture) {\n    var texture = item._texture.baseTexture;\n\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction drawText(helper, item) {\n  if (item instanceof Text) {\n    // updating text will return early if it is not dirty\n    item.updateText(true);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction calculateTextStyle(helper, item) {\n  if (item instanceof TextStyle) {\n    var font = item.toFontString();\n    TextMetrics.measureFont(font);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\n\n\nfunction findText(item, queue) {\n  if (item instanceof Text) {\n    // push the text style to prepare it - this can be really expensive\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    } // also push the text object so that we can render it (to canvas/texture) if needed\n\n\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    } // also push the Text's texture for upload to GPU\n\n\n    var texture = item._texture.baseTexture;\n\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\n\n\nfunction findTextStyle(item, queue) {\n  if (item instanceof TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\n\n\nvar Prepare = /*@__PURE__*/function (BasePrepare) {\n  function Prepare(renderer) {\n    BasePrepare.call(this, renderer);\n    this.uploadHookHelper = this.renderer; // Add textures and graphics to upload\n\n    this.registerFindHook(findGraphics);\n    this.registerUploadHook(uploadBaseTextures);\n    this.registerUploadHook(uploadGraphics);\n  }\n\n  if (BasePrepare) Prepare.__proto__ = BasePrepare;\n  Prepare.prototype = Object.create(BasePrepare && BasePrepare.prototype);\n  Prepare.prototype.constructor = Prepare;\n  return Prepare;\n}(BasePrepare);\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.BaseTexture} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof BaseTexture) {\n    // if the texture already has a GL texture, then the texture has been prepared or rendered\n    // before now. If the texture changed, then the changer should be calling texture.update() which\n    // reuploads the texture without need for preparing it again\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics)) {\n    return false;\n  }\n\n  var geometry = item.geometry; // update dirty graphics to get batches\n\n  item.finishPoly();\n  geometry.updateBatches();\n  var batches = geometry.batches; // upload all textures found in styles\n\n  for (var i = 0; i < batches.length; i++) {\n    var ref = batches[i].style;\n    var texture = ref.texture;\n\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  } // if its not batchable - update vao for particular shader\n\n\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader());\n  }\n\n  return true;\n}\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Graphics object was found.\n */\n\n\nfunction findGraphics(item, queue) {\n  if (item instanceof Graphics) {\n    queue.push(item);\n    return true;\n  }\n\n  return false;\n}\n/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar TimeLimiter = function TimeLimiter(maxMilliseconds) {\n  /**\n   * The maximum milliseconds that can be spent preparing items each frame.\n   * @type {number}\n   * @private\n   */\n  this.maxMilliseconds = maxMilliseconds;\n  /**\n   * The start time of the current frame.\n   * @type {number}\n   * @private\n   */\n\n  this.frameStart = 0;\n};\n/**\n * Resets any counting properties to start fresh on a new frame.\n */\n\n\nTimeLimiter.prototype.beginFrame = function beginFrame() {\n  this.frameStart = Date.now();\n};\n/**\n * Checks to see if another item can be uploaded. This should only be called once per item.\n * @return {boolean} If the item is allowed to be uploaded.\n */\n\n\nTimeLimiter.prototype.allowedToUpload = function allowedToUpload() {\n  return Date.now() - this.frameStart < this.maxMilliseconds;\n};\n\nexport { BasePrepare, CountLimiter, Prepare, TimeLimiter };","map":{"version":3,"sources":["../src/settings.js","../src/CountLimiter.js","../src/BasePrepare.js","../src/Prepare.js","../src/TimeLimiter.js"],"names":["this","let","const","i","len","super"],"mappings":"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","sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\nsettings.UPLOADS_PER_FRAME = 4;\n\nexport { settings };\n","/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class CountLimiter\n{\n    /**\n     * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n     */\n    constructor(maxItemsPerFrame)\n    {\n        /**\n         * The maximum number of items that can be prepared each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxItemsPerFrame = maxItemsPerFrame;\n        /**\n         * The number of items that can be prepared in the current frame.\n         * @type {number}\n         * @private\n         */\n        this.itemsLeft = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.itemsLeft = this.maxItemsPerFrame;\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return this.itemsLeft-- > 0;\n    }\n}\n","import { Texture, BaseTexture } from '@pixi/core';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { settings } from '@pixi/settings';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\nimport { CountLimiter } from './CountLimiter';\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\nexport class BasePrepare\n{\n    /**\n     * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.AbstractRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and Prepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {object}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {this} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get children recursively\n        if (item instanceof Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            Ticker.system.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with multiple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param {PIXI.Texture} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    if (item.baseTexture instanceof BaseTexture)\n    {\n        const texture = item.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof TextStyle)\n    {\n        const font = item.toFontString();\n\n        TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { BaseTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare';\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare\n{\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.BaseTexture} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item)\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[renderer.CONTEXT_UID])\n        {\n            renderer.texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadGraphics(renderer, item)\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        renderer.geometry.bind(geometry, item._resolveDirectShader());\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue)\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n","/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class TimeLimiter\n{\n    /**\n     * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.\n     */\n    constructor(maxMilliseconds)\n    {\n        /**\n         * The maximum milliseconds that can be spent preparing items each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxMilliseconds = maxMilliseconds;\n        /**\n         * The start time of the current frame.\n         * @type {number}\n         * @private\n         */\n        this.frameStart = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.frameStart = Date.now();\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return Date.now() - this.frameStart < this.maxMilliseconds;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
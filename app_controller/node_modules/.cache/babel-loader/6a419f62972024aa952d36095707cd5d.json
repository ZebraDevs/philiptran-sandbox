{"ast":null,"code":"/*!\n * @pixi/graphics - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, BaseTexture, BatchDrawCall, BatchTextureArray, BatchGeometry, UniformGroup, Shader, State } from '@pixi/core';\nimport { SHAPES, Point, Polygon, PI_2, Matrix, Rectangle, RoundedRectangle, Circle, Ellipse } from '@pixi/math';\nimport { earcut, hex2rgb, premultiplyTint, deprecation } from '@pixi/utils';\nimport { WRAP_MODES, DRAW_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Bounds, Container } from '@pixi/display';\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\n\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  _segmentsCount: function _segmentsCount(length, defaultSegments) {\n    if (defaultSegments === void 0) defaultSegments = 20;\n\n    if (!this.adaptive || !length || Number.isNaN(length)) {\n      return defaultSegments;\n    }\n\n    var result = Math.ceil(length / this.maxLength);\n\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n\n    return result;\n  }\n};\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\n\nvar FillStyle = function FillStyle() {\n  this.reset();\n};\n/**\n * Clones the object\n *\n * @return {PIXI.FillStyle}\n */\n\n\nFillStyle.prototype.clone = function clone() {\n  var obj = new FillStyle();\n  obj.color = this.color;\n  obj.alpha = this.alpha;\n  obj.texture = this.texture;\n  obj.matrix = this.matrix;\n  obj.visible = this.visible;\n  return obj;\n};\n/**\n * Reset\n */\n\n\nFillStyle.prototype.reset = function reset() {\n  /**\n   * The hex color value used when coloring the Graphics object.\n   *\n   * @member {number}\n   * @default 1\n   */\n  this.color = 0xFFFFFF;\n  /**\n   * The alpha value used when filling the Graphics object.\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.alpha = 1;\n  /**\n   * The texture to be used for the fill.\n   *\n   * @member {string}\n   * @default 0\n   */\n\n  this.texture = Texture.WHITE;\n  /**\n   * The transform aplpied to the texture.\n   *\n   * @member {string}\n   * @default 0\n   */\n\n  this.matrix = null;\n  /**\n   * If the current fill is visible.\n   *\n   * @member {boolean}\n   * @default false\n   */\n\n  this.visible = false;\n};\n/**\n * Destroy and don't use after this\n */\n\n\nFillStyle.prototype.destroy = function destroy() {\n  this.texture = null;\n  this.matrix = null;\n};\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\n\nvar buildPoly = {\n  build: function build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n\n    if (points.length >= 6) {\n      var holeArray = []; // Process holes..\n\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      } // sort color\n\n\n      var triangles = earcut(points, holeArray, 2);\n\n      if (!triangles) {\n        return;\n      }\n\n      var vertPos = verts.length / 2;\n\n      for (var i$1 = 0; i$1 < triangles.length; i$1 += 3) {\n        indices.push(triangles[i$1] + vertPos);\n        indices.push(triangles[i$1 + 1] + vertPos);\n        indices.push(triangles[i$1 + 2] + vertPos);\n      }\n\n      for (var i$2 = 0; i$2 < points.length; i$2++) {\n        verts.push(points[i$2]);\n      }\n    }\n  }\n};\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\nvar buildCircle = {\n  build: function build(graphicsData) {\n    // need to convert points to a nice regular data\n    var circleData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = circleData.x;\n    var y = circleData.y;\n    var width;\n    var height;\n    points.length = 0; // TODO - bit hacky??\n\n    if (graphicsData.type === SHAPES.CIRC) {\n      width = circleData.radius;\n      height = circleData.radius;\n    } else {\n      width = circleData.width;\n      height = circleData.height;\n    }\n\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n    totalSegs /= 2.3;\n    var seg = Math.PI * 2 / totalSegs;\n\n    for (var i = 0; i < totalSegs - 0.5; i++) {\n      points.push(x + Math.sin(-seg * i) * width, y + Math.cos(-seg * i) * height);\n    }\n\n    points.push(points[0], points[1]);\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    verts.push(graphicsData.shape.x, graphicsData.shape.y);\n\n    for (var i = 0; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]); // add some uvs\n\n      indices.push(vertPos++, center, vertPos);\n    }\n  }\n};\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\nvar buildRectangle = {\n  build: function build(graphicsData) {\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\nvar buildRoundedRectangle = {\n  build: function build(graphicsData) {\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n    var radius = rrectData.radius;\n    points.length = 0;\n    quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);\n    quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);\n    quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);\n    quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points); // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = earcut(points, null, 2);\n\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos); //     indices.push(triangles[i] + vecPos);\n\n      indices.push(triangles[i + 1] + vecPos); //   indices.push(triangles[i + 2] + vecPos);\n\n      indices.push(triangles[i + 2] + vecPos);\n    }\n\n    for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++) {\n      verts.push(points[i$1], points[++i$1]);\n    }\n  }\n};\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\n\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\n\n\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) out = [];\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n; // The Green Line\n\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j); // The Black Dot\n\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    points.push(x, y);\n  }\n\n  return points;\n}\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n\n  if (points.length === 0) {\n    return;\n  } // if the line width is an odd number add 0.5 to align to a whole pixel\n  // commenting this out fixes #711 and #1620\n  // if (graphicsData.lineWidth%2)\n  // {\n  //     for (i = 0; i < points.length; i++)\n  //     {\n  //         points[i] += 0.5;\n  //     }\n  // }\n\n\n  var style = graphicsData.lineStyle; // get first and last point.. figure out the middle!\n\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps; // if the first point is the last point - gonna have issues :)\n\n  if (closedShape) {\n    // need to clone as we are going to slightly modify the shape..\n    points = points.slice();\n\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n\n    var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;\n    var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2; // DRAW the Line\n\n  var width = style.width / 2; // sort color\n\n  var p1x = points[0];\n  var p1y = points[1];\n  var p2x = points[2];\n  var p2y = points[3];\n  var p3x = 0;\n  var p3y = 0;\n  var perpx = -(p1y - p2y);\n  var perpy = p1x - p2x;\n  var perp2x = 0;\n  var perp2y = 0;\n  var perp3x = 0;\n  var perp3y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment; // 0.5;\n\n  var r1 = (1 - ratio) * 2;\n  var r2 = ratio * 2; // start\n\n  verts.push(p1x - perpx * r1, p1y - perpy * r1);\n  verts.push(p1x + perpx * r2, p1y + perpy * r2);\n\n  for (var i = 1; i < length - 1; ++i) {\n    p1x = points[(i - 1) * 2];\n    p1y = points[(i - 1) * 2 + 1];\n    p2x = points[i * 2];\n    p2y = points[i * 2 + 1];\n    p3x = points[(i + 1) * 2];\n    p3y = points[(i + 1) * 2 + 1];\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp2x = -(p2y - p3y);\n    perp2y = p2x - p3x;\n    dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);\n    perp2x /= dist;\n    perp2y /= dist;\n    perp2x *= width;\n    perp2y *= width;\n    var a1 = -perpy + p1y - (-perpy + p2y);\n    var b1 = -perpx + p2x - (-perpx + p1x);\n    var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n    var a2 = -perp2y + p3y - (-perp2y + p2y);\n    var b2 = -perp2x + p2x - (-perp2x + p3x);\n    var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n    var denom = a1 * b2 - a2 * b1;\n\n    if (Math.abs(denom) < 0.1) {\n      denom += 10.1;\n      verts.push(p2x - perpx * r1, p2y - perpy * r1);\n      verts.push(p2x + perpx * r2, p2y + perpy * r2);\n      continue;\n    }\n\n    var px = (b1 * c2 - b2 * c1) / denom;\n    var py = (a2 * c1 - a1 * c2) / denom;\n    var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);\n\n    if (pdist > 196 * width * width) {\n      perp3x = perpx - perp2x;\n      perp3y = perpy - perp2y;\n      dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);\n      perp3x /= dist;\n      perp3y /= dist;\n      perp3x *= width;\n      perp3y *= width;\n      verts.push(p2x - perp3x * r1, p2y - perp3y * r1);\n      verts.push(p2x + perp3x * r2, p2y + perp3y * r2);\n      verts.push(p2x - perp3x * r2 * r1, p2y - perp3y * r1);\n      indexCount++;\n    } else {\n      verts.push(p2x + (px - p2x) * r1, p2y + (py - p2y) * r1);\n      verts.push(p2x - (px - p2x) * r2, p2y - (py - p2y) * r2);\n    }\n  }\n\n  p1x = points[(length - 2) * 2];\n  p1y = points[(length - 2) * 2 + 1];\n  p2x = points[(length - 1) * 2];\n  p2y = points[(length - 1) * 2 + 1];\n  perpx = -(p1y - p2y);\n  perpy = p1x - p2x;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(p2x - perpx * r1, p2y - perpy * r1);\n  verts.push(p2x + perpx * r2, p2y + perpy * r2);\n  var indices = graphicsGeometry.indices; // indices.push(indexStart);\n\n  for (var i$1 = 0; i$1 < indexCount - 2; ++i$1) {\n    indices.push(indexStart, indexStart + 1, indexStart + 2);\n    indexStart++;\n  }\n}\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n  if (points.length === 0) {\n    return;\n  }\n\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\n/**\n * Builds a complex polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.Graphics} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n */\n\n\nfunction buildComplexPoly(graphicsData, webGLData) {\n  // TODO - no need to copy this as it gets turned into a Float32Array anyways..\n  var points = graphicsData.points.slice();\n\n  if (points.length < 6) {\n    return;\n  } // get first and last point.. figure out the middle!\n\n\n  var indices = webGLData.indices;\n  webGLData.points = points;\n  webGLData.alpha = graphicsData.fillAlpha;\n  webGLData.color = hex2rgb(graphicsData.fillColor); // calculate the bounds..\n\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n  var x = 0;\n  var y = 0; // get size..\n\n  for (var i = 0; i < points.length; i += 2) {\n    x = points[i];\n    y = points[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  } // add a quad to the end cos there is no point making another buffer!\n\n\n  points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY); // push a quad onto the end..\n  // TODO - this ain't needed!\n\n  var length = points.length / 2;\n\n  for (var i$1 = 0; i$1 < length; i$1++) {\n    indices.push(i$1);\n  }\n}\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @param {number} fromX - Starting point x\n * @param {number} fromY - Starting point y\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} cpX2 - Second Control point x\n * @param {number} cpY2 - Second Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number} n - Number of segments approximating the bezier curve\n * @param {number[]} [path=[]] - Path array to push points into\n * @return {number[]} Array of points of the curve\n */\n\n\nfunction bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, path) {\n  if (path === void 0) path = [];\n  var dt = 0;\n  var dt2 = 0;\n  var dt3 = 0;\n  var t2 = 0;\n  var t3 = 0;\n  path.push(fromX, fromY);\n\n  for (var i = 1, j = 0; i <= n; ++i) {\n    j = i / n;\n    dt = 1 - j;\n    dt2 = dt * dt;\n    dt3 = dt2 * dt;\n    t2 = j * j;\n    t3 = t2 * j;\n    path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n  }\n\n  return path;\n}\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\n\n\nvar Star = /*@__PURE__*/function (Polygon) {\n  function Star(x, y, points, radius, innerRadius, rotation) {\n    innerRadius = innerRadius || radius / 2;\n    var startAngle = -1 * Math.PI / 2 + rotation;\n    var len = points * 2;\n    var delta = PI_2 / len;\n    var polygon = [];\n\n    for (var i = 0; i < len; i++) {\n      var r = i % 2 ? innerRadius : radius;\n      var angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n\n    Polygon.call(this, polygon);\n  }\n\n  if (Polygon) Star.__proto__ = Polygon;\n  Star.prototype = Object.create(Polygon && Polygon.prototype);\n  Star.prototype.constructor = Star;\n  return Star;\n}(Polygon);\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\n\n\nvar ArcUtils = function ArcUtils() {};\n\nArcUtils.curveTo = function curveTo(x1, y1, x2, y2, radius, points) {\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  var a1 = fromY - y1;\n  var b1 = fromX - x1;\n  var a2 = y2 - y1;\n  var b2 = x2 - x1;\n  var mm = Math.abs(a1 * b2 - b1 * a2);\n\n  if (mm < 1.0e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n\n    return null;\n  }\n\n  var dd = a1 * a1 + b1 * b1;\n  var cc = a2 * a2 + b2 * b2;\n  var tt = a1 * a2 + b1 * b2;\n  var k1 = radius * Math.sqrt(dd) / mm;\n  var k2 = radius * Math.sqrt(cc) / mm;\n  var j1 = k1 * tt / dd;\n  var j2 = k2 * tt / cc;\n  var cx = k1 * b2 + k2 * b1;\n  var cy = k1 * a2 + k2 * a1;\n  var px = b1 * (k2 + j1);\n  var py = a1 * (k2 + j1);\n  var qx = b2 * (k1 + j2);\n  var qy = a2 * (k1 + j2);\n  var startAngle = Math.atan2(py - cy, px - cx);\n  var endAngle = Math.atan2(qy - cy, qx - cx);\n  return {\n    cx: cx + x1,\n    cy: cy + y1,\n    radius: radius,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    anticlockwise: b1 * a2 > b2 * a1\n  };\n};\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @private\n * @param {number} startX - Start x location of arc\n * @param {number} startY - Start y location of arc\n * @param {number} cx - The x-coordinate of the center of the circle\n * @param {number} cy - The y-coordinate of the center of the circle\n * @param {number} radius - The radius of the circle\n * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n *  of the arc's circle)\n * @param {number} endAngle - The ending angle, in radians\n * @param {boolean} anticlockwise - Specifies whether the drawing should be\n *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n *  indicates counter-clockwise.\n * @param {number} n - Number of segments\n * @param {number[]} points - Collection of points to add to\n */\n\n\nArcUtils.arc = function arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) {\n  var sweep = endAngle - startAngle;\n\n  var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n\n  var theta = sweep / (n * 2);\n  var theta2 = theta * 2;\n  var cTheta = Math.cos(theta);\n  var sTheta = Math.sin(theta);\n  var segMinus = n - 1;\n  var remainder = segMinus % 1 / segMinus;\n\n  for (var i = 0; i <= segMinus; ++i) {\n    var real = i + remainder * i;\n    var angle = theta + startAngle + theta2 * real;\n    var c = Math.cos(angle);\n    var s = -Math.sin(angle);\n    points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n  }\n};\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\n\n\nvar BezierUtils = function BezierUtils() {};\n\nBezierUtils.curveLength = function curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n  var n = 10;\n  var result = 0.0;\n  var t = 0.0;\n  var t2 = 0.0;\n  var t3 = 0.0;\n  var nt = 0.0;\n  var nt2 = 0.0;\n  var nt3 = 0.0;\n  var x = 0.0;\n  var y = 0.0;\n  var dx = 0.0;\n  var dy = 0.0;\n  var prevX = fromX;\n  var prevY = fromY;\n\n  for (var i = 1; i <= n; ++i) {\n    t = i / n;\n    t2 = t * t;\n    t3 = t2 * t;\n    nt = 1.0 - t;\n    nt2 = nt * nt;\n    nt3 = nt2 * nt;\n    x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n    y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n    dx = prevX - x;\n    dy = prevY - y;\n    prevX = x;\n    prevY = y;\n    result += Math.sqrt(dx * dx + dy * dy);\n  }\n\n  return result;\n};\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} cpX2 - Second Control point x\n * @param {number} cpY2 - Second Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} points - Path array to push points into\n */\n\n\nBezierUtils.curveTo = function curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  points.length -= 2;\n\n  var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n\n  var dt = 0;\n  var dt2 = 0;\n  var dt3 = 0;\n  var t2 = 0;\n  var t3 = 0;\n  points.push(fromX, fromY);\n\n  for (var i = 1, j = 0; i <= n; ++i) {\n    j = i / n;\n    dt = 1 - j;\n    dt2 = dt * dt;\n    dt3 = dt2 * dt;\n    t2 = j * j;\n    t3 = t2 * j;\n    points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n  }\n};\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\n\n\nvar QuadraticUtils = function QuadraticUtils() {};\n\nQuadraticUtils.curveLength = function curveLength(fromX, fromY, cpX, cpY, toX, toY) {\n  var ax = fromX - 2.0 * cpX + toX;\n  var ay = fromY - 2.0 * cpY + toY;\n  var bx = 2.0 * cpX - 2.0 * fromX;\n  var by = 2.0 * cpY - 2.0 * fromY;\n  var a = 4.0 * (ax * ax + ay * ay);\n  var b = 4.0 * (ax * bx + ay * by);\n  var c = bx * bx + by * by;\n  var s = 2.0 * Math.sqrt(a + b + c);\n  var a2 = Math.sqrt(a);\n  var a32 = 2.0 * a * a2;\n  var c2 = 2.0 * Math.sqrt(c);\n  var ba = b / a2;\n  return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n};\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @private\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} points - Points to add segments to.\n */\n\n\nQuadraticUtils.curveTo = function curveTo(cpX, cpY, toX, toY, points) {\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n\n  var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n\n  var xa = 0;\n  var ya = 0;\n\n  for (var i = 1; i <= n; ++i) {\n    var j = i / n;\n    xa = fromX + (cpX - fromX) * j;\n    ya = fromY + (cpY - fromY) * j;\n    points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n  }\n};\n/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\n\n\nvar BatchPart = function BatchPart() {\n  this.reset();\n};\n/**\n * Begin batch part\n *\n * @param {PIXI.FillStyle | PIXI.LineStyle} style\n * @param {number} startIndex\n * @param {number} attribStart\n */\n\n\nBatchPart.prototype.begin = function begin(style, startIndex, attribStart) {\n  this.reset();\n  this.style = style;\n  this.start = startIndex;\n  this.attribStart = attribStart;\n};\n/**\n * End batch part\n *\n * @param {number} endIndex\n * @param {number} endAttrib\n */\n\n\nBatchPart.prototype.end = function end(endIndex, endAttrib) {\n  this.attribSize = endAttrib - this.attribStart;\n  this.size = endIndex - this.start;\n};\n\nBatchPart.prototype.reset = function reset() {\n  this.style = null;\n  this.size = 0;\n  this.start = 0;\n  this.attribStart = 0;\n  this.attribSize = 0;\n};\n/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace PIXI.graphicsUtils\n */\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object}\n */\n\n\nvar FILL_COMMANDS = {};\nFILL_COMMANDS[SHAPES.POLY] = buildPoly;\nFILL_COMMANDS[SHAPES.CIRC] = buildCircle;\nFILL_COMMANDS[SHAPES.ELIP] = buildCircle;\nFILL_COMMANDS[SHAPES.RECT] = buildRectangle;\nFILL_COMMANDS[SHAPES.RREC] = buildRoundedRectangle;\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.graphicsUtils.BatchPart>}\n */\n\nvar BATCH_POOL = [];\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.BatchDrawCall>}\n */\n\nvar DRAW_CALL_POOL = [];\nvar index = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL,\n  buildLine: buildLine,\n  buildComplexPoly: buildComplexPoly,\n  bezierCurveTo: bezierCurveTo,\n  Star: Star,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart\n};\n/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\n\nvar GraphicsData = function GraphicsData(shape, fillStyle, lineStyle, matrix) {\n  if (fillStyle === void 0) fillStyle = null;\n  if (lineStyle === void 0) lineStyle = null;\n  if (matrix === void 0) matrix = null;\n  /**\n   * The shape object to draw.\n   * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n   */\n\n  this.shape = shape;\n  /**\n   * The style of the line.\n   * @member {PIXI.LineStyle}\n   */\n\n  this.lineStyle = lineStyle;\n  /**\n   * The style of the fill.\n   * @member {PIXI.FillStyle}\n   */\n\n  this.fillStyle = fillStyle;\n  /**\n   * The transform matrix.\n   * @member {PIXI.Matrix}\n   */\n\n  this.matrix = matrix;\n  /**\n   * The type of the shape, see the Const.Shapes file for all the existing types,\n   * @member {number}\n   */\n\n  this.type = shape.type;\n  /**\n   * The collection of points.\n   * @member {number[]}\n   */\n\n  this.points = [];\n  /**\n   * The collection of holes.\n   * @member {PIXI.GraphicsData[]}\n   */\n\n  this.holes = [];\n};\n/**\n * Creates a new GraphicsData object with the same values as this one.\n *\n * @return {PIXI.GraphicsData} Cloned GraphicsData object\n */\n\n\nGraphicsData.prototype.clone = function clone() {\n  return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n};\n/**\n * Destroys the Graphics data.\n */\n\n\nGraphicsData.prototype.destroy = function destroy() {\n  this.shape = null;\n  this.holes.length = 0;\n  this.holes = null;\n  this.points.length = 0;\n  this.points = null;\n  this.lineStyle = null;\n  this.fillStyle = null;\n};\n\nvar tmpPoint = new Point();\nvar tmpBounds = new Bounds();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\n\nvar GraphicsGeometry = /*@__PURE__*/function (BatchGeometry) {\n  function GraphicsGeometry() {\n    BatchGeometry.call(this);\n    /**\n     * An array of points to draw, 2 numbers per point\n     *\n     * @member {number[]}\n     * @protected\n     */\n\n    this.points = [];\n    /**\n     * The collection of colors\n     *\n     * @member {number[]}\n     * @protected\n     */\n\n    this.colors = [];\n    /**\n     * The UVs collection\n     *\n     * @member {number[]}\n     * @protected\n     */\n\n    this.uvs = [];\n    /**\n     * The indices of the vertices\n     *\n     * @member {number[]}\n     * @protected\n     */\n\n    this.indices = [];\n    /**\n     * Reference to the texture IDs.\n     *\n     * @member {number[]}\n     * @protected\n     */\n\n    this.textureIds = [];\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     * @protected\n     */\n\n    this.graphicsData = [];\n    /**\n     * Used to detect if the graphics object has changed.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this.dirty = 0;\n    /**\n     * Batches need to regenerated if the geometry is updated.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this.batchDirty = -1;\n    /**\n     * Used to check if the cache is dirty.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this.cacheDirty = -1;\n    /**\n     * Used to detect if we cleared the graphicsData.\n     *\n     * @member {number}\n     * @default 0\n     * @protected\n     */\n\n    this.clearDirty = 0;\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {object[]}\n     * @protected\n     */\n\n    this.drawCalls = [];\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     * @protected\n     */\n\n    this.batches = [];\n    /**\n     * Index of the last batched shape in the stack of calls.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this.shapeIndex = 0;\n    /**\n     * Cached bounds.\n     *\n     * @member {PIXI.Bounds}\n     * @protected\n     */\n\n    this._bounds = new Bounds();\n    /**\n     * The bounds dirty flag.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this.boundsDirty = -1;\n    /**\n     * Padding to add to the bounds.\n     *\n     * @member {number}\n     * @default 0\n     */\n\n    this.boundsPadding = 0;\n    this.batchable = false;\n    this.indicesUint16 = null;\n    this.uvsFloat32 = null;\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     *\n     * @member {number}\n     */\n\n    this.closePointEps = 1e-4;\n  }\n\n  if (BatchGeometry) GraphicsGeometry.__proto__ = BatchGeometry;\n  GraphicsGeometry.prototype = Object.create(BatchGeometry && BatchGeometry.prototype);\n  GraphicsGeometry.prototype.constructor = GraphicsGeometry;\n  var prototypeAccessors = {\n    bounds: {\n      configurable: true\n    }\n  };\n  /**\n   * Get the current bounds of the graphic geometry.\n   *\n   * @member {PIXI.Bounds}\n   * @readonly\n   */\n\n  prototypeAccessors.bounds.get = function () {\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.calculateBounds();\n    }\n\n    return this._bounds;\n  };\n  /**\n   * Call if you changed graphicsData manually.\n   * Empties all batch buffers.\n   */\n\n\n  GraphicsGeometry.prototype.invalidate = function invalidate() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].textures.length = 0;\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n\n    this.drawCalls.length = 0;\n\n    for (var i$1 = 0; i$1 < this.batches.length; i$1++) {\n      var batchPart = this.batches[i$1];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n\n    this.batches.length = 0;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n   */\n\n\n  GraphicsGeometry.prototype.clear = function clear() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n   * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n   * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n   * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n   */\n\n\n  GraphicsGeometry.prototype.drawShape = function drawShape(shape, fillStyle, lineStyle, matrix) {\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n   * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n   */\n\n\n  GraphicsGeometry.prototype.drawHole = function drawHole(shape, matrix) {\n    if (!this.graphicsData.length) {\n      return null;\n    }\n\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  GraphicsGeometry.prototype.destroy = function destroy(options) {\n    BatchGeometry.prototype.destroy.call(this, options); // destroy each of the GraphicsData objects\n\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  /**\n   * Check to see if a point is contained within this geometry.\n   *\n   * @param {PIXI.Point} point - Point to check if it's contained.\n   * @return {Boolean} `true` if the point is contained within geometry.\n   */\n\n\n  GraphicsGeometry.prototype.containsPoint = function containsPoint(point) {\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n\n      if (!data.fillStyle.visible) {\n        continue;\n      } // only deal with fills..\n\n\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n\n          if (data.holes) {\n            for (var i$1 = 0; i$1 < data.holes.length; i$1++) {\n              var hole = data.holes[i$1];\n\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   */\n\n\n  GraphicsGeometry.prototype.updateBatches = function updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n\n    if (!this.validateBatching()) {\n      return;\n    }\n\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n\n    for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      var data = graphicsData[i];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type]; // build out the shapes points..\n\n      command.build(data);\n\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n\n      for (var j = 0; j < 2; j++) {\n        var style = j === 0 ? fillStyle : lineStyle;\n\n        if (!style.visible) {\n          continue;\n        }\n\n        var nextTexture = style.texture.baseTexture;\n        var index = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n\n        var size = this.points.length / 2 - attribIndex;\n\n        if (size === 0) {\n          continue;\n        } // close batch if style is different\n\n\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index, attribIndex);\n          batchPart = null;\n        } // spawn new batch if its first batch or previous was closed\n\n\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n\n    if (batchPart) {\n      var index$1 = this.indices.length;\n      var attrib = this.points.length / 2;\n      batchPart.end(index$1, attrib);\n    }\n\n    if (this.batches.length === 0) {\n      // there are no visible styles in GraphicsData\n      // its possible that someone wants Graphics just for the bounds\n      this.batchable = true;\n      return;\n    }\n\n    this.indicesUint16 = new Uint16Array(this.indices); // TODO make this a const..\n\n    this.batchable = this.isBatchable();\n\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  /**\n   * Affinity check\n   *\n   * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n   * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n   */\n\n\n  GraphicsGeometry.prototype._compareStyles = function _compareStyles(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Test geometry for batching process.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.validateBatching = function validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n\n    for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n      var data = this.graphicsData[i];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Offset the indices so that it works with the batcher.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.packBatches = function packBatches() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n\n    for (var i = 0, l = batches.length; i < l; i++) {\n      var batch = batches[i];\n\n      for (var j = 0; j < batch.size; j++) {\n        var index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.isBatchable = function isBatchable() {\n    var batches = this.batches;\n\n    for (var i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n\n    return this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2;\n  };\n  /**\n   * Converts intermediate batches data to drawCalls.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.buildDrawCalls = function buildDrawCalls() {\n    var TICK = ++BaseTexture._globalBatch;\n\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].textures.length = 0;\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.textures = new BatchTextureArray();\n    }\n\n    currentGroup.textures.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = DRAW_MODES.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup); // TODO - this can be simplified\n\n    for (var i$1 = 0; i$1 < this.batches.length; i$1++) {\n      var data = this.batches[i$1]; // TODO add some full on MAX_TEXTURE CODE..\n\n      var MAX_TEXTURES = 8;\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES; // force the batch to break!\n\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.textures = new BatchTextureArray();\n              }\n\n              this.drawCalls.push(currentGroup);\n            }\n\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.textures.count = 0;\n            currentGroup.type = drawMode;\n          } // TODO add this to the render part..\n\n\n          nextTexture.touched = 1; // touch;\n\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = 10497;\n          currentGroup.textures.elements[currentGroup.textures.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize);\n      this.addTextureIds(textureIds, textureId, data.attribSize);\n    }\n\n    BaseTexture._globalBatch = TICK; // upload..\n    // merge for now!\n\n    this.packAttributes();\n  };\n  /**\n   * Packs attributes to single buffer.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.packAttributes = function packAttributes() {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds; // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p = 0;\n\n    for (var i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n\n    this._buffer.update(glPoints);\n\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  /**\n   * Process fill part of Graphics.\n   *\n   * @param {PIXI.GraphicsData} data\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.processFill = function processFill(data) {\n    if (data.holes.length) {\n      this.processHoles(data.holes);\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  /**\n   * Process line part of Graphics.\n   *\n   * @param {PIXI.GraphicsData} data\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.processLine = function processLine(data) {\n    buildLine(data, this);\n\n    for (var i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  };\n  /**\n   * Process the holes data.\n   *\n   * @param {PIXI.GraphicsData[]} holes - Holes to render\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.processHoles = function processHoles(holes) {\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  /**\n   * Update the local bounds of the object. Expensive to use performance-wise.\n   *\n   * @protected\n   */\n\n\n  GraphicsGeometry.prototype.calculateBounds = function calculateBounds() {\n    var bounds = this._bounds;\n    var sequenceBounds = tmpBounds;\n    var curMatrix = Matrix.IDENTITY;\n\n    this._bounds.clear();\n\n    sequenceBounds.clear();\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var shape = data.shape;\n      var type = data.type;\n      var lineStyle = data.lineStyle;\n      var nextMatrix = data.matrix || Matrix.IDENTITY;\n      var lineWidth = 0.0;\n\n      if (lineStyle && lineStyle.visible) {\n        var alignment = lineStyle.alignment;\n        lineWidth = lineStyle.width;\n\n        if (type === SHAPES.POLY) {\n          lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n        } else {\n          lineWidth = lineWidth * Math.max(0, alignment);\n        }\n      }\n\n      if (curMatrix !== nextMatrix) {\n        if (!sequenceBounds.isEmpty()) {\n          bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n          sequenceBounds.clear();\n        }\n\n        curMatrix = nextMatrix;\n      }\n\n      if (type === SHAPES.RECT || type === SHAPES.RREC) {\n        sequenceBounds.addFramePad(shape.x, shape.y, shape.x + shape.width, shape.y + shape.height, lineWidth, lineWidth);\n      } else if (type === SHAPES.CIRC) {\n        sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y, shape.radius + lineWidth, shape.radius + lineWidth);\n      } else if (type === SHAPES.ELIP) {\n        sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y, shape.width + lineWidth, shape.height + lineWidth);\n      } else {\n        // adding directly to the bounds\n        bounds.addVerticesMatrix(curMatrix, shape.points, 0, shape.points.length, lineWidth, lineWidth);\n      }\n    }\n\n    if (!sequenceBounds.isEmpty()) {\n      bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n    }\n\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  /**\n   * Transform points using matrix.\n   *\n   * @protected\n   * @param {number[]} points - Points to transform\n   * @param {PIXI.Matrix} matrix - Transform matrix\n   */\n\n\n  GraphicsGeometry.prototype.transformPoints = function transformPoints(points, matrix) {\n    for (var i = 0; i < points.length / 2; i++) {\n      var x = points[i * 2];\n      var y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  };\n  /**\n   * Add colors.\n   *\n   * @protected\n   * @param {number[]} colors - List of colors to add to\n   * @param {number} color - Color to add\n   * @param {number} alpha - Alpha to use\n   * @param {number} size - Number of colors to add\n   */\n\n\n  GraphicsGeometry.prototype.addColors = function addColors(colors, color, alpha, size) {\n    // TODO use the premultiply bits Ivan added\n    var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n    var rgba = premultiplyTint(rgb, alpha);\n\n    while (size-- > 0) {\n      colors.push(rgba);\n    }\n  };\n  /**\n   * Add texture id that the shader/fragment wants to use.\n   *\n   * @protected\n   * @param {number[]} textureIds\n   * @param {number} id\n   * @param {number} size\n   */\n\n\n  GraphicsGeometry.prototype.addTextureIds = function addTextureIds(textureIds, id, size) {\n    while (size-- > 0) {\n      textureIds.push(id);\n    }\n  };\n  /**\n   * Generates the UVs for a shape.\n   *\n   * @protected\n   * @param {number[]} verts - Vertices\n   * @param {number[]} uvs - UVs\n   * @param {PIXI.Texture} texture - Reference to Texture\n   * @param {number} start - Index buffer start index.\n   * @param {number} size - The size/length for index buffer.\n   * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n   */\n\n\n  GraphicsGeometry.prototype.addUvs = function addUvs(verts, uvs, texture, start, size, matrix) {\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n\n    while (index < size) {\n      var x = verts[(start + index) * 2];\n      var y = verts[(start + index) * 2 + 1];\n\n      if (matrix) {\n        var nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n\n    var baseTexture = texture.baseTexture;\n\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   *\n   * @param {number[]} uvs array\n   * @param {PIXI.Texture} texture region\n   * @param {number} start starting index for uvs\n   * @param {number} size how many points to adjust\n   */\n\n\n  GraphicsGeometry.prototype.adjustUvs = function adjustUvs(uvs, texture, start, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start] + eps);\n    var minY = Math.floor(uvs[start + 1] + eps);\n\n    for (var i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n\n    offsetX -= minX;\n    offsetY -= minY;\n\n    for (var i$1 = start; i$1 < finish; i$1 += 2) {\n      uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;\n      uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;\n    }\n  };\n\n  Object.defineProperties(GraphicsGeometry.prototype, prototypeAccessors);\n  return GraphicsGeometry;\n}(BatchGeometry);\n/**\n * The maximum number of points to consider an object \"batchable\",\n * able to be batched by the renderer's batch system.\n *\n * @memberof PIXI.GraphicsGeometry\n * @static\n * @member {number} BATCHABLE_SIZE\n * @default 100\n */\n\n\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\n\nvar LineStyle = /*@__PURE__*/function (FillStyle) {\n  function LineStyle() {\n    FillStyle.apply(this, arguments);\n  }\n\n  if (FillStyle) LineStyle.__proto__ = FillStyle;\n  LineStyle.prototype = Object.create(FillStyle && FillStyle.prototype);\n  LineStyle.prototype.constructor = LineStyle;\n\n  LineStyle.prototype.clone = function clone() {\n    var obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    return obj;\n  };\n  /**\n   * Reset the line style to default.\n   */\n\n\n  LineStyle.prototype.reset = function reset() {\n    FillStyle.prototype.reset.call(this); // Override default line style color\n\n    this.color = 0x0;\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n\n    this.width = 0;\n    /**\n     * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n     *\n     * @member {number}\n     * @default 0\n     */\n\n    this.alignment = 0.5;\n    /**\n     * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.native = false;\n  };\n\n  return LineStyle;\n}(FillStyle);\n\nvar temp = new Float32Array(3); // a default shaders map used by graphics..\n\nvar DEFAULT_SHADERS = {};\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\nvar Graphics = /*@__PURE__*/function (Container) {\n  function Graphics(geometry) {\n    if (geometry === void 0) geometry = null;\n    Container.call(this);\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     * @member {PIXI.GraphicsGeometry}\n     * @readonly\n     */\n\n    this.geometry = geometry || new GraphicsGeometry();\n    this.geometry.refCount++;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     * @member {PIXI.Shader}\n     */\n\n    this.shader = null;\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     * @member {PIXI.State}\n     */\n\n    this.state = State.for2d();\n    /**\n     * Current fill style\n     *\n     * @member {PIXI.FillStyle}\n     * @protected\n     */\n\n    this._fillStyle = new FillStyle();\n    /**\n     * Current line style\n     *\n     * @member {PIXI.LineStyle}\n     * @protected\n     */\n\n    this._lineStyle = new LineStyle();\n    /**\n     * Current shape transform matrix.\n     *\n     * @member {PIXI.Matrix}\n     * @protected\n     */\n\n    this._matrix = null;\n    /**\n     * Current hole mode is enabled.\n     *\n     * @member {boolean}\n     * @default false\n     * @protected\n     */\n\n    this._holeMode = false;\n    /**\n     * Current path\n     *\n     * @member {PIXI.Polygon}\n     * @protected\n     */\n\n    this.currentPath = null;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n\n    /**\n     * A collections of batches! These can be drawn by the renderer batch system.\n     *\n     * @protected\n     * @member {object[]}\n     */\n\n    this.batches = [];\n    /**\n     * Update dirty for limiting calculating tints for batches.\n     *\n     * @protected\n     * @member {number}\n     * @default -1\n     */\n\n    this.batchTint = -1;\n    /**\n     * Copy of the object vertex data.\n     *\n     * @protected\n     * @member {Float32Array}\n     */\n\n    this.vertexData = null;\n    this._transformID = -1;\n    this.batchDirty = -1;\n    /**\n     * Renderer plugin for batching\n     *\n     * @member {string}\n     * @default 'batch'\n     */\n\n    this.pluginName = 'batch'; // Set default\n\n    this.tint = 0xFFFFFF;\n    this.blendMode = BLEND_MODES.NORMAL;\n  }\n\n  if (Container) Graphics.__proto__ = Container;\n  Graphics.prototype = Object.create(Container && Container.prototype);\n  Graphics.prototype.constructor = Graphics;\n  var prototypeAccessors = {\n    blendMode: {\n      configurable: true\n    },\n    tint: {\n      configurable: true\n    },\n    fill: {\n      configurable: true\n    },\n    line: {\n      configurable: true\n    }\n  };\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n   *\n   * @return {PIXI.Graphics} A clone of the graphics object\n   */\n\n  Graphics.prototype.clone = function clone() {\n    this.finishPoly();\n    return new Graphics(this.geometry);\n  };\n  /**\n   * The blend mode to be applied to the graphic shape. Apply a value of\n   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n   *\n   * @member {number}\n   * @default PIXI.BLEND_MODES.NORMAL;\n   * @see PIXI.BLEND_MODES\n   */\n\n\n  prototypeAccessors.blendMode.set = function (value) {\n    this.state.blendMode = value;\n  };\n\n  prototypeAccessors.blendMode.get = function () {\n    return this.state.blendMode;\n  };\n  /**\n   * The tint applied to the graphic shape. This is a hex value. A value of\n   * 0xFFFFFF will remove any tint effect.\n   *\n   * @member {number}\n   * @default 0xFFFFFF\n   */\n\n\n  prototypeAccessors.tint.get = function () {\n    return this._tint;\n  };\n\n  prototypeAccessors.tint.set = function (value) {\n    this._tint = value;\n  };\n  /**\n   * The current fill style.\n   *\n   * @member {PIXI.FillStyle}\n   * @readonly\n   */\n\n\n  prototypeAccessors.fill.get = function () {\n    return this._fillStyle;\n  };\n  /**\n   * The current line style.\n   *\n   * @member {PIXI.LineStyle}\n   * @readonly\n   */\n\n\n  prototypeAccessors.line.get = function () {\n    return this._lineStyle;\n  };\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @method PIXI.Graphics#lineStyle\n   * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n   * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @param {object} [options] - Line style options\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineStyle = function lineStyle(options) {\n    // Support non-object params: (width, color, alpha, alignment, native)\n    if (typeof options === 'number') {\n      var args = arguments;\n      options = {\n        width: args[0] || 0,\n        color: args[1] || 0x0,\n        alpha: args[2] !== undefined ? args[2] : 1,\n        alignment: args[3] !== undefined ? args[3] : 0.5,\n        native: !!args[4]\n      };\n    }\n\n    return this.lineTextureStyle(options);\n  };\n  /**\n   * Like line style but support texture for line fill.\n   *\n   * @param {object} [options] - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineTextureStyle = function lineTextureStyle(options) {\n    // backward compatibility with params: (width, texture,\n    // color, alpha, matrix, alignment, native)\n    if (typeof options === 'number') {\n      deprecation('v5.2.0', 'Please use object-based options for Graphics#lineTextureStyle');\n      var width = arguments[0];\n      var texture = arguments[1];\n      var color = arguments[2];\n      var alpha = arguments[3];\n      var matrix = arguments[4];\n      var alignment = arguments[5];\n      var native = arguments[6];\n      options = {\n        width: width,\n        texture: texture,\n        color: color,\n        alpha: alpha,\n        matrix: matrix,\n        alignment: alignment,\n        native: native\n      }; // Remove undefined keys\n\n      Object.keys(options).forEach(function (key) {\n        return options[key] === undefined && delete options[key];\n      });\n    } // Apply defaults\n\n\n    options = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: options && options.texture ? 0xFFFFFF : 0x0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false\n    }, options);\n\n    if (this.currentPath) {\n      this.startPoly();\n    }\n\n    var visible = options.width > 0 && options.alpha > 0;\n\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n\n      Object.assign(this._lineStyle, {\n        visible: visible\n      }, options);\n    }\n\n    return this;\n  };\n  /**\n   * Start a polygon object internally\n   * @protected\n   */\n\n\n  Graphics.prototype.startPoly = function startPoly() {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  /**\n   * Finish the polygon object.\n   * @protected\n   */\n\n\n  Graphics.prototype.finishPoly = function finishPoly() {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param {number} x - the X coordinate to move to\n   * @param {number} y - the Y coordinate to move to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.moveTo = function moveTo(x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param {number} x - the X coordinate to draw to\n   * @param {number} y - the Y coordinate to draw to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineTo = function lineTo(x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    } // remove duplicates..\n\n\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n\n    return this;\n  };\n  /**\n   * Initialize the curve\n   *\n   * @protected\n   * @param {number} [x=0]\n   * @param {number} [y=0]\n   */\n\n\n  Graphics.prototype._initCurve = function _initCurve(x, y) {\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._initCurve();\n\n    var points = this.currentPath.points;\n\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n   * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n   * @param {number} x2 - The x-coordinate of the end of the arc\n   * @param {number} y2 - The y-coordinate of the end of the arc\n   * @param {number} radius - The radius of the arc\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n    if (result) {\n      var cx = result.cx;\n      var cy = result.cy;\n      var radius$1 = result.radius;\n      var startAngle = result.startAngle;\n      var endAngle = result.endAngle;\n      var anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);\n    }\n\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param {number} cx - The x-coordinate of the center of the circle\n   * @param {number} cy - The y-coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param {number} endAngle - The ending angle, in radians\n   * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) anticlockwise = false;\n\n    if (startAngle === endAngle) {\n      return this;\n    }\n\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n\n    var sweep = endAngle - startAngle;\n\n    if (sweep === 0) {\n      return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this.geometry.closePointEps; // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n\n    var points = this.currentPath ? this.currentPath.points : null;\n\n    if (points) {\n      // TODO: make a better fix.\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) ;else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param {number} [color=0] - the color of the fill\n   * @param {number} [alpha=1] - the alpha of the fill\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.beginFill = function beginFill(color, alpha) {\n    if (color === void 0) color = 0;\n    if (alpha === void 0) alpha = 1;\n    return this.beginTextureFill({\n      texture: Texture.WHITE,\n      color: color,\n      alpha: alpha\n    });\n  };\n  /**\n   * Begin the texture fill\n   *\n   * @param {object} [options] - Object object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {number} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha=1] - Alpha of fill\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.beginTextureFill = function beginTextureFill(options) {\n    // backward compatibility with params: (texture, color, alpha, matrix)\n    if (options instanceof Texture) {\n      deprecation('v5.2.0', 'Please use object-based options for Graphics#beginTextureFill');\n      var texture = arguments[0];\n      var color = arguments[1];\n      var alpha = arguments[2];\n      var matrix = arguments[3];\n      options = {\n        texture: texture,\n        color: color,\n        alpha: alpha,\n        matrix: matrix\n      }; // Remove undefined keys\n\n      Object.keys(options).forEach(function (key) {\n        return options[key] === undefined && delete options[key];\n      });\n    } // Apply defaults\n\n\n    options = Object.assign({\n      texture: Texture.WHITE,\n      color: 0xFFFFFF,\n      alpha: 1,\n      matrix: null\n    }, options);\n\n    if (this.currentPath) {\n      this.startPoly();\n    }\n\n    var visible = options.alpha > 0;\n\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n\n      Object.assign(this._fillStyle, {\n        visible: visible\n      }, options);\n    }\n\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.endFill = function endFill() {\n    this.finishPoly();\n\n    this._fillStyle.reset();\n\n    return this;\n  };\n  /**\n   * Draws a rectangle shape.\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRect = function drawRect(x, y, width, height) {\n    return this.drawShape(new Rectangle(x, y, width, height));\n  };\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @param {number} radius - Radius of the rectangle corners\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  };\n  /**\n   * Draws a circle.\n   *\n   * @param {number} x - The X coordinate of the center of the circle\n   * @param {number} y - The Y coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  };\n  /**\n   * Draws an ellipse.\n   *\n   * @param {number} x - The X coordinate of the center of the ellipse\n   * @param {number} y - The Y coordinate of the center of the ellipse\n   * @param {number} width - The half width of the ellipse\n   * @param {number} height - The half height of the ellipse\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  };\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawPolygon = function drawPolygon(path) {\n    var arguments$1 = arguments; // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n\n    var points = path;\n    var closeStroke = true; // !!this._fillStyle;\n    // check if data has points..\n\n    if (points.points) {\n      closeStroke = points.closeStroke;\n      points = points.points;\n    }\n\n    if (!Array.isArray(points)) {\n      // prevents an argument leak deopt\n      // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n      points = new Array(arguments.length);\n\n      for (var i = 0; i < points.length; ++i) {\n        points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params\n      }\n    }\n\n    var shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw any shape.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawShape = function drawShape(shape) {\n    if (!this._holeMode) {\n      this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this.geometry.drawHole(shape, this._matrix);\n    }\n\n    return this;\n  };\n  /**\n   * Draw a star shape with an arbitrary number of points.\n   *\n   * @param {number} x - Center X position of the star\n   * @param {number} y - Center Y position of the star\n   * @param {number} points - The number of points of the star, must be > 1\n   * @param {number} radius - The outer radius of the star\n   * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n   * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawStar = function drawStar(x, y, points, radius, innerRadius, rotation) {\n    if (rotation === void 0) rotation = 0;\n    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.clear = function clear() {\n    this.geometry.clear();\n\n    this._lineStyle.reset();\n\n    this._fillStyle.reset();\n\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns {boolean} True if only 1 rect.\n   */\n\n\n  Graphics.prototype.isFastRect = function isFastRect() {\n    return this.geometry.graphicsData.length === 1 && this.geometry.graphicsData[0].shape.type === SHAPES.RECT && !this.geometry.graphicsData[0].lineWidth;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._render = function _render(renderer) {\n    this.finishPoly();\n    var geometry = this.geometry; // batch part..\n    // batch it!\n\n    geometry.updateBatches();\n\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n\n      this._renderBatched(renderer);\n    } else {\n      // no batching...\n      renderer.batch.flush();\n\n      this._renderDirect(renderer);\n    }\n  };\n  /**\n   * Populating batches for rendering\n   *\n   * @protected\n   */\n\n\n  Graphics.prototype._populateBatches = function _populateBatches() {\n    var geometry = this.geometry;\n    var blendMode = this.blendMode;\n    this.batches = [];\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.vertexData = new Float32Array(geometry.points);\n\n    for (var i = 0, l = geometry.batches.length; i < l; i++) {\n      var gI = geometry.batches[i];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData: vertexData,\n        blendMode: blendMode,\n        indices: indices,\n        uvs: uvs,\n        _batchRGB: hex2rgb(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  };\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderBatched = function _renderBatched(renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n\n    for (var i = 0, l = this.batches.length; i < l; i++) {\n      var batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  /**\n   * Renders the graphics direct\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderDirect = function _renderDirect(renderer) {\n    var shader = this._resolveDirectShader(renderer);\n\n    var geometry = this.geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls; // lets set the transfomr\n\n    uniforms.translationMatrix = this.transform.worldTransform; // and then lets set the tint..\n\n    uniforms.tint[0] = (tint >> 16 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha; // the first draw call, we can set the uniforms of the shader directly here.\n    // this means that we can tack advantage of the sync function of pixi!\n    // bind and sync uniforms..\n    // there is a way to optimise this..\n\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader); // set state..\n\n    renderer.state.set(this.state); // then render the rest of them...\n\n    for (var i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  };\n  /**\n   * Renders specific DrawCall\n   *\n   * @param {PIXI.Renderer} renderer\n   * @param {PIXI.BatchDrawCall} drawCall\n   */\n\n\n  Graphics.prototype._renderDrawCallDirect = function _renderDrawCallDirect(renderer, drawCall) {\n    var textures = drawCall.textures;\n    var type = drawCall.type;\n    var size = drawCall.size;\n    var start = drawCall.start;\n    var groupTextureCount = textures.count;\n\n    for (var j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(textures.elements[j], j);\n    }\n\n    renderer.geometry.draw(type, size, start);\n  };\n  /**\n   * Resolves shader for direct rendering\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._resolveDirectShader = function _resolveDirectShader(renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n\n    if (!shader) {\n      // if there is no shader here, we can use the default shader.\n      // and that only gets created if we actually need it..\n      // but may be more than one plugins for graphics\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var sampleValues = new Int32Array(16);\n\n        for (var i = 0; i < 16; i++) {\n          sampleValues[i] = i;\n        }\n\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({\n            uSamplers: sampleValues\n          }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n\n    return shader;\n  };\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object\n   *\n   * @protected\n   */\n\n\n  Graphics.prototype._calculateBounds = function _calculateBounds() {\n    this.finishPoly();\n    var geometry = this.geometry; // skipping when graphics is empty, like a container\n\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n\n    var ref = geometry.bounds;\n    var minX = ref.minX;\n    var minY = ref.minY;\n    var maxX = ref.maxX;\n    var maxY = ref.maxY;\n\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param {PIXI.Point} point - the point to test\n   * @return {boolean} the result of the test\n   */\n\n\n  Graphics.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n    return this.geometry.containsPoint(Graphics._TEMP_POINT);\n  };\n  /**\n   * Recalcuate the tint by applying tin to batches using Graphics tint.\n   * @protected\n   */\n\n\n  Graphics.prototype.calculateTints = function calculateTints() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = hex2rgb(this.tint, temp);\n\n      for (var i = 0; i < this.batches.length; i++) {\n        var batch = this.batches[i];\n        var batchTint = batch._batchRGB;\n        var r = tintRGB[0] * batchTint[0] * 255;\n        var g = tintRGB[1] * batchTint[1] * 255;\n        var b = tintRGB[2] * batchTint[2] * 255; // TODO Ivan, can this be done in one go?\n\n        var color = (r << 16) + (g << 8) + (b | 0);\n        batch._tintRGB = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n      }\n    }\n  };\n  /**\n   * If there's a transform update or a change to the shape of the\n   * geometry, recaculate the vertices.\n   * @protected\n   */\n\n\n  Graphics.prototype.calculateVertices = function calculateVertices() {\n    if (this._transformID === this.transform._worldID) {\n      return;\n    }\n\n    this._transformID = this.transform._worldID;\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this.geometry.points; // batch.vertexDataOriginal;\n\n    var vertexData = this.vertexData;\n    var count = 0;\n\n    for (var i = 0; i < data.length; i += 2) {\n      var x = data[i];\n      var y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  };\n  /**\n   * Closes the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.closePath = function closePath() {\n    var currentPath = this.currentPath;\n\n    if (currentPath) {\n      // we don't need to add extra point in the end because buildLine will take care of that\n      currentPath.closeStroke = true;\n    }\n\n    return this;\n  };\n  /**\n   * Apply a matrix to the positional data.\n   *\n   * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.setMatrix = function setMatrix(matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.beginHole = function beginHole() {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  /**\n   * End adding holes to the last draw shape\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.endHole = function endHole() {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Graphics.prototype.destroy = function destroy(options) {\n    Container.prototype.destroy.call(this, options);\n    this.geometry.refCount--;\n\n    if (this.geometry.refCount === 0) {\n      this.geometry.dispose();\n    }\n\n    this._matrix = null;\n    this.currentPath = null;\n\n    this._lineStyle.destroy();\n\n    this._lineStyle = null;\n\n    this._fillStyle.destroy();\n\n    this._fillStyle = null;\n    this.geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    Container.prototype.destroy.call(this, options);\n  };\n\n  Object.defineProperties(Graphics.prototype, prototypeAccessors);\n  return Graphics;\n}(Container);\n/**\n * Temporary point to use for containsPoint\n *\n * @static\n * @private\n * @member {PIXI.Point}\n */\n\n\nGraphics._TEMP_POINT = new Point();\nexport { FillStyle, GRAPHICS_CURVES, Graphics, GraphicsData, GraphicsGeometry, LineStyle, index as graphicsUtils };","map":{"version":3,"sources":["../src/const.js","../src/styles/FillStyle.js","../src/utils/buildPoly.js","../src/utils/buildCircle.js","../src/utils/buildRectangle.js","../src/utils/buildRoundedRectangle.js","../src/utils/buildLine.js","../src/utils/buildComplexPoly.js","../src/utils/bezierCurveTo.js","../src/utils/Star.js","../src/utils/ArcUtils.js","../src/utils/BezierUtils.js","../src/utils/QuadraticUtils.js","../src/utils/BatchPart.js","../src/utils/index.js","../src/GraphicsData.js","../src/GraphicsGeometry.js","../src/styles/LineStyle.js","../src/Graphics.js"],"names":["let","const","i","j","super","index","radius","arguments"],"mappings":"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","sourcesContent":["/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments: 2048,\n    _segmentsCount(length, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || Number.isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.FillStyle}\n     */\n    clone()\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /**\n     * Reset\n     */\n    reset()\n    {\n        /**\n         * The hex color value used when coloring the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.color = 0xFFFFFF;\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.alpha = 1;\n\n        /**\n         * The texture to be used for the fill.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.texture = Texture.WHITE;\n\n        /**\n         * The transform aplpied to the texture.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.matrix = null;\n\n        /**\n         * If the current fill is visible.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.visible = false;\n    }\n\n    /**\n     * Destroy and don't use after this\n     */\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = graphicsData.shape.points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","import { SHAPES } from '@pixi/math';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n\n        points.length = 0;\n\n        // TODO - bit hacky??\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            width = circleData.width;\n            height = circleData.height;\n        }\n\n        if (width === 0 || height === 0)\n        {\n            return;\n        }\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n\n        totalSegs /= 2.3;\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n\n        points.push(\n            points[0],\n            points[1]\n        );\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        verts.push(graphicsData.shape.x, graphicsData.shape.y);\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n    },\n};\n","/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle = {\n\n    build(graphicsData)\n    {\n        const rrectData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        const radius = rrectData.radius;\n\n        points.length = 0;\n\n        quadraticBezierCurve(x, y + radius,\n            x, y,\n            x + radius, y,\n            points);\n        quadraticBezierCurve(x + width - radius,\n            y, x + width, y,\n            x + width, y + radius,\n            points);\n        quadraticBezierCurve(x + width, y + height - radius,\n            x + width, y + height,\n            x + width - radius, y + height,\n            points);\n        quadraticBezierCurve(x + radius, y + height,\n            x, y + height,\n            x, y + height - radius,\n            points);\n\n        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n        // TODO - fix this properly, this is not very elegant.. but it works for now.\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc)\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n","import { Point, SHAPES } from '@pixi/math';\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData, graphicsGeometry)\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData, graphicsGeometry)\n{\n    const shape = graphicsData.shape;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);\n        const midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    let indexStart = verts.length / 2;\n\n    // DRAW the Line\n    const width = style.width / 2;\n\n    // sort color\n    let p1x = points[0];\n    let p1y = points[1];\n    let p2x = points[2];\n    let p2y = points[3];\n    let p3x = 0;\n    let p3y = 0;\n\n    let perpx = -(p1y - p2y);\n    let perpy = p1x - p2x;\n    let perp2x = 0;\n    let perp2y = 0;\n    let perp3x = 0;\n    let perp3y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const r1 = (1 - ratio) * 2;\n    const r2 = ratio * 2;\n\n    // start\n    verts.push(\n        p1x - (perpx * r1),\n        p1y - (perpy * r1));\n\n    verts.push(\n        p1x + (perpx * r2),\n        p1y + (perpy * r2));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        p1x = points[(i - 1) * 2];\n        p1y = points[((i - 1) * 2) + 1];\n\n        p2x = points[i * 2];\n        p2y = points[(i * 2) + 1];\n\n        p3x = points[(i + 1) * 2];\n        p3y = points[((i + 1) * 2) + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        const a1 = (-perpy + p1y) - (-perpy + p2y);\n        const b1 = (-perpx + p2x) - (-perpx + p1x);\n        const c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));\n        const a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        const b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        const c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));\n\n        let denom = (a1 * b2) - (a2 * b1);\n\n        if (Math.abs(denom) < 0.1)\n        {\n            denom += 10.1;\n            verts.push(\n                p2x - (perpx * r1),\n                p2y - (perpy * r1));\n\n            verts.push(\n                p2x + (perpx * r2),\n                p2y + (perpy * r2));\n\n            continue;\n        }\n\n        const px = ((b1 * c2) - (b2 * c1)) / denom;\n        const py = ((a2 * c1) - (a1 * c2)) / denom;\n        const pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));\n\n        if (pdist > (196 * width * width))\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));\n\n            verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));\n\n            verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));\n\n            indexCount++;\n        }\n        else\n        {\n            verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));\n\n            verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));\n        }\n    }\n\n    p1x = points[(length - 2) * 2];\n    p1y = points[((length - 2) * 2) + 1];\n\n    p2x = points[(length - 1) * 2];\n    p2y = points[((length - 1) * 2) + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - (perpx * r1), p2y - (perpy * r1));\n\n    verts.push(p2x + (perpx * r2), p2y + (perpy * r2));\n\n    const indices = graphicsGeometry.indices;\n\n    // indices.push(indexStart);\n\n    for (let i = 0; i < indexCount - 2; ++i)\n    {\n        indices.push(indexStart, indexStart + 1, indexStart + 2);\n\n        indexStart++;\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry)\n{\n    let i = 0;\n\n    const shape = graphicsData.shape;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n","import { hex2rgb } from '@pixi/utils';\n\n/**\n * Builds a complex polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.Graphics} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n */\nexport function buildComplexPoly(graphicsData, webGLData)\n{\n    // TODO - no need to copy this as it gets turned into a Float32Array anyways..\n    const points = graphicsData.points.slice();\n\n    if (points.length < 6)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n    const indices = webGLData.indices;\n\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = hex2rgb(graphicsData.fillColor);\n\n    // calculate the bounds..\n    let minX = Infinity;\n    let maxX = -Infinity;\n\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    let x = 0;\n    let y = 0;\n\n    // get size..\n    for (let i = 0; i < points.length; i += 2)\n    {\n        x = points[i];\n        y = points[i + 1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n        maxX, minY,\n        maxX, maxY,\n        minX, maxY);\n\n    // push a quad onto the end..\n\n    // TODO - this ain't needed!\n    const length = points.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        indices.push(i);\n    }\n}\n","/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @param {number} fromX - Starting point x\n * @param {number} fromY - Starting point y\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} cpX2 - Second Control point x\n * @param {number} cpY2 - Second Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number} n - Number of segments approximating the bezier curve\n * @param {number[]} [path=[]] - Path array to push points into\n * @return {number[]} Array of points of the curve\n */\nexport function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, path = [])\n{\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n\n    path.push(fromX, fromY);\n\n    for (let i = 1, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        path.push(\n            (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n            (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n        );\n    }\n\n    return path;\n}\n","import { Polygon, PI_2 } from '@pixi/math';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport class Star extends Polygon\n{\n    constructor(x, y, points, radius, innerRadius, rotation)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1, y1, x2, y2, radius, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param {number} startX - Start x location of arc\n     * @param {number} startY - Start y location of arc\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param {number} n - Number of segments\n     * @param {number[]} points - Collection of points to add to\n     */\n    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points)\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Path array to push points into\n     */\n    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, toX, toY)\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Points to add segments to.\n     */\n    static curveTo(cpX, cpY, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} style\n     * @param {number} startIndex\n     * @param {number} attribStart\n     */\n    begin(style, startIndex, attribStart)\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part\n     *\n     * @param {number} endIndex\n     * @param {number} endAttrib\n     */\n    end(endIndex, endAttrib)\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    reset()\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n","/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace PIXI.graphicsUtils\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './buildComplexPoly';\nexport * from './bezierCurveTo';\nexport * from './Star';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\nimport { SHAPES } from '@pixi/math';\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object}\n */\nexport const FILL_COMMANDS = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.graphicsUtils.BatchPart>}\n */\nexport const BATCH_POOL = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.BatchDrawCall>}\n */\nexport const DRAW_CALL_POOL = [];\n","/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     *\n     * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n     * @param {PIXI.Matrix} [matrix] - Transform matrix\n     */\n    constructor(shape, fillStyle = null, lineStyle = null, matrix = null)\n    {\n        /**\n         * The shape object to draw.\n         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n         */\n        this.shape = shape;\n\n        /**\n         * The style of the line.\n         * @member {PIXI.LineStyle}\n         */\n        this.lineStyle = lineStyle;\n\n        /**\n         * The style of the fill.\n         * @member {PIXI.FillStyle}\n         */\n        this.fillStyle = fillStyle;\n\n        /**\n         * The transform matrix.\n         * @member {PIXI.Matrix}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The type of the shape, see the Const.Shapes file for all the existing types,\n         * @member {number}\n         */\n        this.type = shape.type;\n\n        /**\n         * The collection of points.\n         * @member {number[]}\n         */\n        this.points = [];\n\n        /**\n         * The collection of holes.\n         * @member {PIXI.GraphicsData[]}\n         */\n        this.holes = [];\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return {PIXI.GraphicsData} Cloned GraphicsData object\n     */\n    clone()\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /**\n     * Destroys the Graphics data.\n     */\n    destroy()\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL } from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture } from '@pixi/core';\n\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    constructor()\n    {\n        super();\n\n        /**\n         * An array of points to draw, 2 numbers per point\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.points = [];\n\n        /**\n         * The collection of colors\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.colors = [];\n\n        /**\n         * The UVs collection\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.uvs = [];\n\n        /**\n         * The indices of the vertices\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.indices = [];\n\n        /**\n         * Reference to the texture IDs.\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.textureIds = [];\n\n        /**\n         * The collection of drawn shapes.\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @protected\n         */\n        this.graphicsData = [];\n\n        /**\n         * Used to detect if the graphics object has changed.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.dirty = 0;\n\n        /**\n         * Batches need to regenerated if the geometry is updated.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.batchDirty = -1;\n\n        /**\n         * Used to check if the cache is dirty.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.cacheDirty = -1;\n\n        /**\n         * Used to detect if we cleared the graphicsData.\n         *\n         * @member {number}\n         * @default 0\n         * @protected\n         */\n        this.clearDirty = 0;\n\n        /**\n         * List of current draw calls drived from the batches.\n         *\n         * @member {object[]}\n         * @protected\n         */\n        this.drawCalls = [];\n\n        /**\n         * Intermediate abstract format sent to batch system.\n         * Can be converted to drawCalls or to batchable objects.\n         *\n         * @member {PIXI.graphicsUtils.BatchPart[]}\n         * @protected\n         */\n        this.batches = [];\n\n        /**\n         * Index of the last batched shape in the stack of calls.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.shapeIndex = 0;\n\n        /**\n         * Cached bounds.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._bounds = new Bounds();\n\n        /**\n         * The bounds dirty flag.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Padding to add to the bounds.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.uvsFloat32 = null;\n\n        /**\n         * Minimal distance between points that are considered different.\n         * Affects line tesselation.\n         *\n         * @member {number}\n         */\n        this.closePointEps = 1e-4;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    get bounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    invalidate()\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawShape(shape, fillStyle, lineStyle, matrix)\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawHole(shape, matrix)\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.Point} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    containsPoint(point)\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches()\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        if (batchPart)\n        {\n            const index = this.indices.length;\n            const attrib = this.points.length / 2;\n\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        this.indicesUint16 = new Uint16Array(this.indices);\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    _compareStyles(styleA, styleB)\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!styleA.native !== !!styleB.native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    validateBatching()\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    packBatches()\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     *\n     * @protected\n     */\n    isBatchable()\n    {\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if (batches[i].style.native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    buildDrawCalls()\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.textures = new BatchTextureArray();\n        }\n        currentGroup.textures.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            const style = data.style;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.textures = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.textures.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    nextTexture.touched = 1;// touch;\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = 10497;\n\n                    currentGroup.textures.elements[currentGroup.textures.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize);\n            this.addTextureIds(textureIds, textureId, data.attribSize);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /**\n     * Packs attributes to single buffer.\n     *\n     * @protected\n     */\n    packAttributes()\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    processFill(data)\n    {\n        if (data.holes.length)\n        {\n            this.processHoles(data.holes);\n\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    processLine(data)\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     *\n     * @param {PIXI.GraphicsData[]} holes - Holes to render\n     * @protected\n     */\n    processHoles(holes)\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    calculateBounds()\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x + shape.width, shape.y + shape.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y,\n                    shape.radius + lineWidth, shape.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y,\n                    shape.width + lineWidth, shape.height + lineWidth);\n            }\n            else\n            {\n                // adding directly to the bounds\n                bounds.addVerticesMatrix(curMatrix, shape.points, 0, shape.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    transformPoints(points, matrix)\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @protected\n     * @param {number[]} colors - List of colors to add to\n     * @param {number} color - Color to add\n     * @param {number} alpha - Alpha to use\n     * @param {number} size - Number of colors to add\n     */\n    addColors(colors, color, alpha, size)\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        while (size-- > 0)\n        {\n            colors.push(rgba);\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     *\n     * @protected\n     * @param {number[]} textureIds\n     * @param {number} id\n     * @param {number} size\n     */\n    addTextureIds(textureIds, id, size)\n    {\n        while (size-- > 0)\n        {\n            textureIds.push(id);\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @protected\n     * @param {number[]} verts - Vertices\n     * @param {number[]} uvs - UVs\n     * @param {PIXI.Texture} texture - Reference to Texture\n     * @param {number} start - Index buffer start index.\n     * @param {number} size - The size/length for index buffer.\n     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n     */\n    addUvs(verts, uvs, texture, start, size, matrix)\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     *\n     * @param {number[]} uvs array\n     * @param {PIXI.Texture} texture region\n     * @param {number} start starting index for uvs\n     * @param {number} size how many points to adjust\n     */\n    adjustUvs(uvs, texture, start, size)\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n\n/**\n * The maximum number of points to consider an object \"batchable\",\n * able to be batched by the renderer's batch system.\n *\n * @memberof PIXI.GraphicsGeometry\n * @static\n * @member {number} BATCHABLE_SIZE\n * @default 100\n */\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n","import { FillStyle } from './FillStyle';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nexport class LineStyle extends FillStyle\n{\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.LineStyle}\n     */\n    clone()\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n\n        return obj;\n    }\n    /**\n     * Reset the line style to default.\n     */\n    reset()\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.width = 0;\n\n        /**\n         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.alignment = 0.5;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.native = false;\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport {\n    Texture,\n    Shader,\n    UniformGroup, State,\n} from '@pixi/core';\n\nimport {\n    BezierUtils,\n    QuadraticUtils,\n    ArcUtils,\n    Star,\n} from './utils';\n\nimport { hex2rgb, deprecation } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS = {};\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n     *        will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry = null)\n    {\n        super();\n        /**\n         * Includes vertex positions, face indices, normals, colors, UVs, and\n         * custom attributes within buffers, reducing the cost of passing all\n         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n         * @member {PIXI.GraphicsGeometry}\n         * @readonly\n         */\n        this.geometry = geometry || new GraphicsGeometry();\n\n        this.geometry.refCount++;\n\n        /**\n         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n         * Can be shared between multiple Graphics objects.\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n         * @member {PIXI.State}\n         */\n        this.state = State.for2d();\n\n        /**\n         * Current fill style\n         *\n         * @member {PIXI.FillStyle}\n         * @protected\n         */\n        this._fillStyle = new FillStyle();\n\n        /**\n         * Current line style\n         *\n         * @member {PIXI.LineStyle}\n         * @protected\n         */\n        this._lineStyle = new LineStyle();\n\n        /**\n         * Current shape transform matrix.\n         *\n         * @member {PIXI.Matrix}\n         * @protected\n         */\n        this._matrix = null;\n\n        /**\n         * Current hole mode is enabled.\n         *\n         * @member {boolean}\n         * @default false\n         * @protected\n         */\n        this._holeMode = false;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.Polygon}\n         * @protected\n         */\n        this.currentPath = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        /**\n         * A collections of batches! These can be drawn by the renderer batch system.\n         *\n         * @protected\n         * @member {object[]}\n         */\n        this.batches = [];\n\n        /**\n         * Update dirty for limiting calculating tints for batches.\n         *\n         * @protected\n         * @member {number}\n         * @default -1\n         */\n        this.batchTint = -1;\n\n        /**\n         * Copy of the object vertex data.\n         *\n         * @protected\n         * @member {Float32Array}\n         */\n        this.vertexData = null;\n\n        this._transformID = -1;\n        this.batchDirty = -1;\n\n        /**\n         * Renderer plugin for batching\n         *\n         * @member {string}\n         * @default 'batch'\n         */\n        this.pluginName = 'batch';\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        this.finishPoly();\n\n        return new Graphics(this.geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    set blendMode(value)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode()\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n    set tint(value)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    get fill()\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    get line()\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @method PIXI.Graphics#lineStyle\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {object} [options] - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(options)\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            const args = arguments;\n\n            options = {\n                width: args[0] || 0,\n                color: args[1] || 0x0,\n                alpha: args[2] !== undefined ? args[2] : 1,\n                alignment: args[3] !== undefined ? args[3] : 0.5,\n                native: !!args[4],\n            };\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param {object} [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTextureStyle(options)\n    {\n        // backward compatibility with params: (width, texture,\n        // color, alpha, matrix, alignment, native)\n        if (typeof options === 'number')\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#lineTextureStyle');\n\n            const [width, texture, color, alpha, matrix, alignment, native] = arguments;\n\n            options = { width, texture, color, alpha, matrix, alignment, native };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => options[key] === undefined && delete options[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally\n     * @protected\n     */\n    startPoly()\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly()\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     *\n     * @protected\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     */\n    _initCurve(x = 0, y = 0)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n     * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this.geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param {object} [options] - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options)\n    {\n        // backward compatibility with params: (texture, color, alpha, matrix)\n        if (options instanceof Texture)\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#beginTextureFill');\n\n            const [texture, color, alpha, matrix] = arguments;\n\n            options = { texture, color, alpha, matrix };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => options[key] === undefined && delete options[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closeStroke = true;// !!this._fillStyle;\n\n        // check if data has points..\n        if (points.points)\n        {\n            closeStroke = points.closeStroke;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawShape(shape)\n    {\n        if (!this._holeMode)\n        {\n            this.geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this.geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an arbitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawStar(x, y, points, radius, innerRadius, rotation = 0)\n    {\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        this.geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        return this.geometry.graphicsData.length === 1\n        && this.geometry.graphicsData[0].shape.type === SHAPES.RECT\n        && !this.geometry.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _render(renderer)\n    {\n        this.finishPoly();\n\n        const geometry = this.geometry;\n\n        // batch part..\n        // batch it!\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /**\n     * Populating batches for rendering\n     *\n     * @protected\n     */\n    _populateBatches()\n    {\n        const geometry = this.geometry;\n        const blendMode = this.blendMode;\n\n        this.batches = [];\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0, l = geometry.batches.length; i < l; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color),\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderBatched(renderer)\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderDirect(renderer)\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this.geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     *\n     * @param {PIXI.Renderer} renderer\n     * @param {PIXI.BatchDrawCall} drawCall\n     */\n    _renderDrawCallDirect(renderer, drawCall)\n    {\n        const { textures, type, size, start } = drawCall;\n        const groupTextureCount = textures.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(textures.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _resolveDirectShader(renderer)\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const sampleValues = new Int32Array(16);\n\n                for (let i = 0; i < 16; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @protected\n     */\n    _calculateBounds()\n    {\n        this.finishPoly();\n\n        const geometry = this.geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this.geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /**\n     * Recalcuate the tint by applying tin to batches using Graphics tint.\n     * @protected\n     */\n    calculateTints()\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recaculate the vertices.\n     * @protected\n     */\n    calculateVertices()\n    {\n        if (this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this.geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    setMatrix(matrix)\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    beginHole()\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    endHole()\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.geometry.refCount--;\n        if (this.geometry.refCount === 0)\n        {\n            this.geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this.geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Temporary point to use for containsPoint\n *\n * @static\n * @private\n * @member {PIXI.Point}\n */\nGraphics._TEMP_POINT = new Point();\n"]},"metadata":{},"sourceType":"module"}
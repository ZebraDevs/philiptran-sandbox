{"ast":null,"code":"/*!\n * @pixi/interaction - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Point } from '@pixi/math';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { DisplayObject } from '@pixi/display';\nimport { EventEmitter } from '@pixi/utils';\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n * @memberof PIXI.interaction\n */\n\nvar InteractionData = function InteractionData() {\n  /**\n   * This point stores the global coords of where the touch/mouse event happened\n   *\n   * @member {PIXI.Point}\n   */\n  this.global = new Point();\n  /**\n   * The target Sprite that was interacted with\n   *\n   * @member {PIXI.Sprite}\n   */\n\n  this.target = null;\n  /**\n   * When passed to an event handler, this will be the original DOM Event that was captured\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n   * @member {MouseEvent|TouchEvent|PointerEvent}\n   */\n\n  this.originalEvent = null;\n  /**\n   * Unique identifier for this interaction\n   *\n   * @member {number}\n   */\n\n  this.identifier = null;\n  /**\n   * Indicates whether or not the pointer device that created the event is the primary pointer.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n   * @type {Boolean}\n   */\n\n  this.isPrimary = false;\n  /**\n   * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n   * @type {number}\n   */\n\n  this.button = 0;\n  /**\n   * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n   * @type {number}\n   */\n\n  this.buttons = 0;\n  /**\n   * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n   * radiusX of TouchEvents will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n   * @type {number}\n   */\n\n  this.width = 0;\n  /**\n   * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n   * radiusY of TouchEvents will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n   * @type {number}\n   */\n\n  this.height = 0;\n  /**\n   * The angle, in degrees, between the pointer device and the screen.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n   * @type {number}\n   */\n\n  this.tiltX = 0;\n  /**\n   * The angle, in degrees, between the pointer device and the screen.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n   * @type {number}\n   */\n\n  this.tiltY = 0;\n  /**\n   * The type of pointer that triggered the event.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n   * @type {string}\n   */\n\n  this.pointerType = null;\n  /**\n   * Pressure applied by the pointing device during the event. A Touch's force property\n   * will be represented by this value.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n   * @type {number}\n   */\n\n  this.pressure = 0;\n  /**\n   * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n   * @type {number}\n   */\n\n  this.rotationAngle = 0;\n  /**\n   * Twist of a stylus pointer.\n   * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n   * @type {number}\n   */\n\n  this.twist = 0;\n  /**\n   * Barrel pressure on a stylus pointer.\n   * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n   * @type {number}\n   */\n\n  this.tangentialPressure = 0;\n};\n\nvar prototypeAccessors = {\n  pointerId: {\n    configurable: true\n  }\n};\n/**\n * The unique identifier of the pointer. It will be the same as `identifier`.\n * @readonly\n * @member {number}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n */\n\nprototypeAccessors.pointerId.get = function () {\n  return this.identifier;\n};\n/**\n * This will return the local coordinates of the specified displayObject for this InteractionData\n *\n * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local\n *  coords off\n * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise\n *  will create a new point)\n * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional\n *  (otherwise will use the current global coords)\n * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative\n *  to the DisplayObject\n */\n\n\nInteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) {\n  return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n};\n/**\n * Copies properties from normalized event data.\n *\n * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n */\n\n\nInteractionData.prototype.copyEvent = function copyEvent(event) {\n  // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n  // it with \"false\" on later events when our shim for it on touch events might not be\n  // accurate\n  if (event.isPrimary) {\n    this.isPrimary = true;\n  }\n\n  this.button = event.button; // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n  // event.which property instead, which conveys the same information.\n\n  this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;\n  this.width = event.width;\n  this.height = event.height;\n  this.tiltX = event.tiltX;\n  this.tiltY = event.tiltY;\n  this.pointerType = event.pointerType;\n  this.pressure = event.pressure;\n  this.rotationAngle = event.rotationAngle;\n  this.twist = event.twist || 0;\n  this.tangentialPressure = event.tangentialPressure || 0;\n};\n/**\n * Resets the data for pooling.\n */\n\n\nInteractionData.prototype.reset = function reset() {\n  // isPrimary is the only property that we really need to reset - everything else is\n  // guaranteed to be overwritten\n  this.isPrimary = false;\n};\n\nObject.defineProperties(InteractionData.prototype, prototypeAccessors);\n/**\n * Event class that mimics native DOM events.\n *\n * @class\n * @memberof PIXI.interaction\n */\n\nvar InteractionEvent = function InteractionEvent() {\n  /**\n   * Whether this event will continue propagating in the tree.\n   *\n   * Remaining events for the {@link stopsPropagatingAt} object\n   * will still be dispatched.\n   *\n   * @member {boolean}\n   */\n  this.stopped = false;\n  /**\n   * At which object this event stops propagating.\n   *\n   * @private\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.stopsPropagatingAt = null;\n  /**\n   * Whether we already reached the element we want to\n   * stop propagating at. This is important for delayed events,\n   * where we start over deeper in the tree again.\n   *\n   * @private\n   * @member {boolean}\n   */\n\n  this.stopPropagationHint = false;\n  /**\n   * The object which caused this event to be dispatched.\n   * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.\n   *\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.target = null;\n  /**\n   * The object whose event listenerâ€™s callback is currently being invoked.\n   *\n   * @member {PIXI.DisplayObject}\n   */\n\n  this.currentTarget = null;\n  /**\n   * Type of the event\n   *\n   * @member {string}\n   */\n\n  this.type = null;\n  /**\n   * InteractionData related to this event\n   *\n   * @member {PIXI.interaction.InteractionData}\n   */\n\n  this.data = null;\n};\n/**\n * Prevents event from reaching any objects other than the current object.\n *\n */\n\n\nInteractionEvent.prototype.stopPropagation = function stopPropagation() {\n  this.stopped = true;\n  this.stopPropagationHint = true;\n  this.stopsPropagatingAt = this.currentTarget;\n};\n/**\n * Resets the event.\n */\n\n\nInteractionEvent.prototype.reset = function reset() {\n  this.stopped = false;\n  this.stopsPropagatingAt = null;\n  this.stopPropagationHint = false;\n  this.currentTarget = null;\n  this.target = null;\n};\n/**\n * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions\n *\n * @class\n * @private\n * @memberof PIXI.interaction\n */\n\n\nvar InteractionTrackingData = function InteractionTrackingData(pointerId) {\n  this._pointerId = pointerId;\n  this._flags = InteractionTrackingData.FLAGS.NONE;\n};\n\nvar prototypeAccessors$1 = {\n  pointerId: {\n    configurable: true\n  },\n  flags: {\n    configurable: true\n  },\n  none: {\n    configurable: true\n  },\n  over: {\n    configurable: true\n  },\n  rightDown: {\n    configurable: true\n  },\n  leftDown: {\n    configurable: true\n  }\n};\n/**\n *\n * @private\n * @param {number} flag - The interaction flag to set\n * @param {boolean} yn - Should the flag be set or unset\n */\n\nInteractionTrackingData.prototype._doSet = function _doSet(flag, yn) {\n  if (yn) {\n    this._flags = this._flags | flag;\n  } else {\n    this._flags = this._flags & ~flag;\n  }\n};\n/**\n * Unique pointer id of the event\n *\n * @readonly\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.pointerId.get = function () {\n  return this._pointerId;\n};\n/**\n * State of the tracking data, expressed as bit flags\n *\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.flags.get = function () {\n  return this._flags;\n};\n\nprototypeAccessors$1.flags.set = function (flags) // eslint-disable-line require-jsdoc\n{\n  this._flags = flags;\n};\n/**\n * Is the tracked event inactive (not over or down)?\n *\n * @private\n * @member {number}\n */\n\n\nprototypeAccessors$1.none.get = function () {\n  return this._flags === this.constructor.FLAGS.NONE;\n};\n/**\n * Is the tracked event over the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.over.get = function () {\n  return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n};\n\nprototypeAccessors$1.over.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.OVER, yn);\n};\n/**\n * Did the right mouse button come down in the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.rightDown.get = function () {\n  return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n};\n\nprototypeAccessors$1.rightDown.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n};\n/**\n * Did the left mouse button come down in the DisplayObject?\n *\n * @private\n * @member {boolean}\n */\n\n\nprototypeAccessors$1.leftDown.get = function () {\n  return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n};\n\nprototypeAccessors$1.leftDown.set = function (yn) // eslint-disable-line require-jsdoc\n{\n  this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n};\n\nObject.defineProperties(InteractionTrackingData.prototype, prototypeAccessors$1);\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2\n});\n/**\n * Strategy how to search through stage tree for interactive objects\n *\n * @private\n * @class\n * @memberof PIXI.interaction\n */\n\nvar TreeSearch = function TreeSearch() {\n  this._tempPoint = new Point();\n};\n/**\n * Recursive implementation for findHit\n *\n * @private\n * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n *  is tested for collision\n * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n *  that will be hit test (recursively crawls its children)\n * @param {Function} [func] - the function that will be called on each interactive object. The\n *  interactionEvent, displayObject and hit will be passed to the function\n * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n * @param {boolean} [interactive] - Whether the displayObject is interactive\n * @return {boolean} returns true if the displayObject hit the point\n */\n\n\nTreeSearch.prototype.recursiveFindHit = function recursiveFindHit(interactionEvent, displayObject, func, hitTest, interactive) {\n  if (!displayObject || !displayObject.visible) {\n    return false;\n  }\n\n  var point = interactionEvent.data.global; // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n  //\n  // This function will now loop through all objects and then only hit test the objects it HAS\n  // to, not all of them. MUCH faster..\n  // An object will be hit test if the following is true:\n  //\n  // 1: It is interactive.\n  // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n  //\n  // As another little optimization once an interactive object has been hit we can carry on\n  // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n  // A final optimization is that an object is not hit test directly if a child has already been hit.\n\n  interactive = displayObject.interactive || interactive;\n  var hit = false;\n  var interactiveParent = interactive; // Flag here can set to false if the event is outside the parents hitArea or mask\n\n  var hitTestChildren = true; // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n  // There is also no longer a need to hitTest children.\n\n  if (displayObject.hitArea) {\n    if (hitTest) {\n      displayObject.worldTransform.applyInverse(point, this._tempPoint);\n\n      if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {\n        hitTest = false;\n        hitTestChildren = false;\n      } else {\n        hit = true;\n      }\n    }\n\n    interactiveParent = false;\n  } // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n  // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n  // https://github.com/pixijs/pixi.js/issues/5135\n  else if (displayObject._mask) {\n      if (hitTest) {\n        if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {\n          hitTest = false;\n        }\n      }\n    } // ** FREE TIP **! If an object is not interactive or has no buttons in it\n  // (such as a game scene!) set interactiveChildren to false for that displayObject.\n  // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\n\n\n  if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {\n    var children = displayObject.children;\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n      var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n\n      if (childHit) {\n        // its a good idea to check if a child has lost its parent.\n        // this means it has been removed whilst looping so its best\n        if (!child.parent) {\n          continue;\n        } // we no longer need to hit test any more objects in this container as we we\n        // now know the parent has been hit\n\n\n        interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n        // interactive and not just the child of an interactive object.\n        // This means we no longer need to hit test anything else. We still need to run\n        // through all objects, but we don't need to perform any hit tests.\n\n        if (childHit) {\n          if (interactionEvent.target) {\n            hitTest = false;\n          }\n\n          hit = true;\n        }\n      }\n    }\n  } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n  if (interactive) {\n    // if we are hit testing (as in we have no hit any objects yet)\n    // We also don't need to worry about hit testing if once of the displayObjects children\n    // has already been hit - but only if it was interactive, otherwise we need to keep\n    // looking for an interactive child, just in case we hit one\n    if (hitTest && !interactionEvent.target) {\n      // already tested against hitArea if it is defined\n      if (!displayObject.hitArea && displayObject.containsPoint) {\n        if (displayObject.containsPoint(point)) {\n          hit = true;\n        }\n      }\n    }\n\n    if (displayObject.interactive) {\n      if (hit && !interactionEvent.target) {\n        interactionEvent.target = displayObject;\n      }\n\n      if (func) {\n        func(interactionEvent, displayObject, !!hit);\n      }\n    }\n  }\n\n  return hit;\n};\n/**\n * This function is provides a neat way of crawling through the scene graph and running a\n * specified function on all interactive objects it finds. It will also take care of hit\n * testing the interactive objects and passes the hit across in the function.\n *\n * @private\n * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n *  is tested for collision\n * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n *  that will be hit test (recursively crawls its children)\n * @param {Function} [func] - the function that will be called on each interactive object. The\n *  interactionEvent, displayObject and hit will be passed to the function\n * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n * @return {boolean} returns true if the displayObject hit the point\n */\n\n\nTreeSearch.prototype.findHit = function findHit(interactionEvent, displayObject, func, hitTest) {\n  this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n};\n/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n *\n * @interface IHitArea\n * @memberof PIXI\n */\n\n/**\n * Checks whether the x and y coordinates given are contained within this area\n *\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this area\n */\n\n/**\n * Default property values of interactive objects\n * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties\n *\n * @private\n * @name interactiveTarget\n * @type {Object}\n * @memberof PIXI.interaction\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interaction.interactiveTarget\n *      );\n */\n\n\nvar interactiveTarget = {\n  /**\n   * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n   * events will not be emitted unless `interactive` is set to `true`.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.on('tap', (event) => {\n   *    //handle event\n   * });\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  interactive: false,\n\n  /**\n   * Determines if the children to the displayObject can be clicked/touched\n   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n   *\n   * @member {boolean}\n   * @memberof PIXI.Container#\n   */\n  interactiveChildren: true,\n\n  /**\n   * Interaction shape. Children will be hit first, then this shape will be checked.\n   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n   * @member {PIXI.IHitArea}\n   * @memberof PIXI.DisplayObject#\n   */\n  hitArea: null,\n\n  /**\n   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n   * Setting this changes the 'cursor' property to `'pointer'`.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.buttonMode = true;\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  get buttonMode() {\n    return this.cursor === 'pointer';\n  },\n\n  set buttonMode(value) {\n    if (value) {\n      this.cursor = 'pointer';\n    } else if (this.cursor === 'pointer') {\n      this.cursor = null;\n    }\n  },\n\n  /**\n   * This defines what cursor mode is used when the mouse cursor\n   * is hovered over the displayObject.\n   *\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.cursor = 'wait';\n   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n   *\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  cursor: null,\n\n  /**\n   * Internal set of all active pointers, by identifier\n   *\n   * @member {Map<number, InteractionTrackingData>}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   */\n  get trackedPointers() {\n    if (this._trackedPointers === undefined) {\n      this._trackedPointers = {};\n    }\n\n    return this._trackedPointers;\n  },\n\n  /**\n   * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n   *\n   * @private\n   * @type {Map<number, InteractionTrackingData>}\n   */\n  _trackedPointers: undefined\n}; // Mix interactiveTarget into DisplayObject.prototype,\n// after deprecation has been handled\n\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI.interaction\n */\n\nvar InteractionManager = /*@__PURE__*/function (EventEmitter) {\n  function InteractionManager(renderer, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {PIXI.AbstractRenderer}\n     */\n\n    this.renderer = renderer;\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n    /**\n     * Maximum requency in milliseconds at which pointer over/out states will be checked by {@link tickerUpdate}.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {PIXI.interaction.InteractionData}\n     */\n\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,PIXI.interaction.InteractionData>}\n     */\n\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {PIXI.interaction.InteractionData[]}\n     */\n\n    this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @protected\n     * @member {HTMLElement}\n     */\n\n    this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM version works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how PixiJS used to work. This will be set to true in\n     * future versions of pixi.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.moveWhenInside = false;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.eventsAdded = false;\n    /**\n     * Has the system ticker been added?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.tickerAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @protected\n     * @member {boolean}\n     */\n\n    this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    this.onPointerOver = this.onPointerOver.bind(this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, Object>}\n     */\n\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    this.cursor = null;\n    /**\n     * The current resolution / device pixel ratio.\n     *\n     * @member {number}\n     * @default 1\n     */\n\n    this.resolution = 1;\n    /**\n     * Delayed pointer events. Used to guarantee correct ordering of over/out events.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this.delayedEvents = [];\n    /**\n     * TreeSearch component that is used to hitTest stage tree\n     *\n     * @private\n     * @member {PIXI.interaction.TreeSearch}\n     */\n\n    this.search = new TreeSearch();\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event PIXI.interaction.InteractionManager#mousedown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event PIXI.interaction.InteractionManager#mouseup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#click\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#rightclick\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.\n     *\n     * @event PIXI.interaction.InteractionManager#mouseupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.\n     *\n     * @event PIXI.interaction.InteractionManager#rightupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mousemove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mouseover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event PIXI.interaction.InteractionManager#mouseout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * Not always fired when some buttons are held down while others are released. In those cases,\n     * use [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown} and\n     * [mouseup]{@link PIXI.interaction.InteractionManager#event:mouseup} instead.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event PIXI.interaction.InteractionManager#pointercancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#pointertap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.\n     *\n     * @event PIXI.interaction.InteractionManager#pointerupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointermove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointerover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event PIXI.interaction.InteractionManager#pointerout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchstart\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchend\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event PIXI.interaction.InteractionManager#touchcancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#tap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.\n     *\n     * @event PIXI.interaction.InteractionManager#touchendoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event PIXI.interaction.InteractionManager#touchmove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mousedown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#click\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightclick\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#rightupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mousemove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#mouseout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerdown\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerup\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointercancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointertap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerupoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointermove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerover\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#pointerout\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchstart\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchend\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchcancel\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#tap\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchendoutside\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event PIXI.DisplayObject#touchmove\n     * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n     */\n\n    this._useSystemTicker = options.useSystemTicker !== undefined ? options.useSystemTicker : true;\n    this.setTargetElement(this.renderer.view, this.renderer.resolution);\n  }\n\n  if (EventEmitter) InteractionManager.__proto__ = EventEmitter;\n  InteractionManager.prototype = Object.create(EventEmitter && EventEmitter.prototype);\n  InteractionManager.prototype.constructor = InteractionManager;\n  var prototypeAccessors = {\n    useSystemTicker: {\n      configurable: true\n    }\n  };\n  /**\n   * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n   *\n   * @member {boolean}\n   * @default true\n   */\n\n  prototypeAccessors.useSystemTicker.get = function () {\n    return this._useSystemTicker;\n  };\n\n  prototypeAccessors.useSystemTicker.set = function (useSystemTicker) {\n    this._useSystemTicker = useSystemTicker;\n\n    if (useSystemTicker) {\n      this.addTickerListener();\n    } else {\n      this.removeTickerListener();\n    }\n  };\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.\n   * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {PIXI.DisplayObject} The hit display object, if any.\n   */\n\n\n  InteractionManager.prototype.hitTest = function hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null; // assign the global point\n\n    hitTestEvent.data.global = globalPoint; // ensure safety of the root\n\n    if (!root) {\n      root = this.renderer._lastObjectRendered;\n    } // run the hit test\n\n\n    this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  };\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLElement} element - the DOM element which will receive mouse and touch events.\n   * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).\n   */\n\n\n  InteractionManager.prototype.setTargetElement = function setTargetElement(element, resolution) {\n    if (resolution === void 0) resolution = 1;\n    this.removeTickerListener();\n    this.removeEvents();\n    this.interactionDOMElement = element;\n    this.resolution = resolution;\n    this.addEvents();\n    this.addTickerListener();\n  };\n  /**\n   * Add the ticker listener\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.addTickerListener = function addTickerListener() {\n    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {\n      return;\n    }\n\n    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n    this.tickerAdded = true;\n  };\n  /**\n   * Remove the ticker listener\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.removeTickerListener = function removeTickerListener() {\n    if (!this.tickerAdded) {\n      return;\n    }\n\n    Ticker.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  };\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.addEvents = function addEvents() {\n    if (this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n    /**\n     * These events are added first, so that if pointer events are normalized, they are fired\n     * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n     */\n\n\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    } // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  };\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n\n\n  InteractionManager.prototype.removeEvents = function removeEvents() {\n    if (!this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n    this.eventsAdded = false;\n  };\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n   *\n   * @param {number} deltaTime - time delta since the last call\n   */\n\n\n  InteractionManager.prototype.tickerUpdate = function tickerUpdate(deltaTime) {\n    this._deltaTime += deltaTime;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n    this.update();\n  };\n  /**\n   * Updates the state of interactive objects.\n   */\n\n\n  InteractionManager.prototype.update = function update() {\n    if (!this.interactionDOMElement) {\n      return;\n    } // if the user move the mouse this check has already been done using the mouse move!\n\n\n    if (this.didMove) {\n      this.didMove = false;\n      return;\n    }\n\n    this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\n\n    for (var k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        var interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n          this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n  };\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n\n\n  InteractionManager.prototype.setCursorMode = function setCursorMode(mode) {\n    mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n\n    this.currentCursorMode = mode;\n    var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  };\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n\n\n  InteractionManager.prototype.dispatchEvent = function dispatchEvent(displayObject, eventString, eventData) {\n    // Even if the event was stopped, at least dispatch any remaining events\n    // for the same display object.\n    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  };\n  /**\n   * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n   * ordering of over/out events.\n   *\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n\n\n  InteractionManager.prototype.delayDispatchEvent = function delayDispatchEvent(displayObject, eventString, eventData) {\n    this.delayedEvents.push({\n      displayObject: displayObject,\n      eventString: eventString,\n      eventData: eventData\n    });\n  };\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {PIXI.Point} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n\n\n  InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint(point, x, y) {\n    var rect; // IE 11 fix\n\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    var resolutionMultiplier = 1.0 / this.resolution;\n    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;\n  };\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @protected\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - indicates whether we want to calculate hits\n   *  or just iterate through all interactive objects\n   */\n\n\n  InteractionManager.prototype.processInteractive = function processInteractive(interactionEvent, displayObject, func, hitTest) {\n    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n    var delayedEvents = this.delayedEvents;\n\n    if (!delayedEvents.length) {\n      return hit;\n    } // Reset the propagation hint, because we start deeper in the tree again.\n\n\n    interactionEvent.stopPropagationHint = false;\n    var delayedLen = delayedEvents.length;\n    this.delayedEvents = [];\n\n    for (var i = 0; i < delayedLen; i++) {\n      var ref = delayedEvents[i];\n      var displayObject$1 = ref.displayObject;\n      var eventString = ref.eventString;\n      var eventData = ref.eventData; // When we reach the object we wanted to stop propagating at,\n      // set the propagation hint.\n\n      if (eventData.stopsPropagatingAt === displayObject$1) {\n        eventData.stopPropagationHint = true;\n      }\n\n      this.dispatchEvent(displayObject$1, eventString, eventData);\n    }\n\n    return hit;\n  };\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n\n\n  InteractionManager.prototype.onPointerDown = function onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent);\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      var cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);\n\n      if (cancelable) {\n        originalEvent.preventDefault();\n      }\n    }\n\n    var eventLen = events.length;\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);\n      this.emit('pointerdown', interactionEvent);\n\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } // emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\n      else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n    }\n  };\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerDown = function processPointerDown(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        var isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n\n\n  InteractionManager.prototype.onPointerComplete = function onPointerComplete(originalEvent, cancelled, func) {\n    var events = this.normalizeToPointerData(originalEvent);\n    var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n\n    var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);\n      this.emit(cancelled ? 'pointercancel' : \"pointerup\" + eventAppend, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? \"rightup\" + eventAppend : \"mouseup\" + eventAppend, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : \"touchend\" + eventAppend, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n\n\n  InteractionManager.prototype.onPointerCancel = function onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  };\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   */\n\n\n  InteractionManager.prototype.processPointerCancel = function processPointerCancel(interactionEvent, displayObject) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n\n\n  InteractionManager.prototype.onPointerUp = function onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  };\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerUp = function processPointerUp(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var trackingData = displayObject.trackedPointers[id];\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // need to track mouse down status in the mouse block so that we can emit\n    // event in a later block\n\n    var isMouseTap = false; // Mouse only\n\n    if (isMouse) {\n      var isRightButton = data.button === 2;\n      var flags = InteractionTrackingData.FLAGS;\n      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n      var isDown = trackingData !== undefined && trackingData.flags & test;\n\n      if (hit) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent); // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\n\n          isMouseTap = true;\n        }\n      } else if (isDown) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      } // update the down state of the tracking data\n\n\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    } // Pointers and Touches, and Mouse\n\n\n    if (hit) {\n      this.dispatchEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (trackingData) {\n        // emit pointertap if not a mouse, or if the mouse block decided it was a tap\n        if (!isMouse || isMouseTap) {\n          this.dispatchEvent(displayObject, 'pointertap', interactionEvent);\n        }\n\n        if (isTouch) {\n          this.dispatchEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);\n      }\n    } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  };\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n\n\n  InteractionManager.prototype.onPointerMove = function onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {\n      this.didMove = true;\n      this.cursor = null;\n    }\n\n    var eventLen = events.length;\n\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, true);\n      this.emit('pointermove', interactionEvent);\n\n      if (event.pointerType === 'touch') {\n        this.emit('touchmove', interactionEvent);\n      }\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mousemove', interactionEvent);\n      }\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n    }\n  };\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerMove = function processPointerMove(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (!this.moveWhenInside || hit) {\n      this.dispatchEvent(displayObject, 'pointermove', interactionEvent);\n\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchmove', interactionEvent);\n      }\n\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n\n\n  InteractionManager.prototype.onPointerOut = function onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n\n    var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n    var event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);\n    this.emit('pointerout', interactionEvent);\n\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  };\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n\n\n  InteractionManager.prototype.processPointerOverOut = function processPointerOverOut(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n    var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) {\n      return;\n    }\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);\n\n        if (isMouse) {\n          this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      } // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n\n\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.dispatchEvent(displayObject, 'pointerout', this.eventData);\n\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mouseout', interactionEvent);\n      } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n\n\n  InteractionManager.prototype.onPointerOver = function onPointerOver(originalEvent) {\n    var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n    var event = events[0];\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  };\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier\n   */\n\n\n  InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId(event) {\n    var pointerId = event.pointerId;\n    var interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    } // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n\n\n    interactionData.copyEvent(event);\n    return interactionData;\n  };\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n\n\n  InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId(pointerId) {\n    var interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData.reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  };\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in\n   */\n\n\n  InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY); // Not really sure why this is happening, but it's how a previous version handled things\n\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent.reset();\n    return interactionEvent;\n  };\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n\n\n  InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData(event) {\n    var normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n        var touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') {\n          touch.button = event.touches.length ? 1 : 0;\n        }\n\n        if (typeof touch.buttons === 'undefined') {\n          touch.buttons = event.touches.length ? 1 : 0;\n        }\n\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n\n        if (typeof touch.width === 'undefined') {\n          touch.width = touch.radiusX || 1;\n        }\n\n        if (typeof touch.height === 'undefined') {\n          touch.height = touch.radiusY || 1;\n        }\n\n        if (typeof touch.tiltX === 'undefined') {\n          touch.tiltX = 0;\n        }\n\n        if (typeof touch.tiltY === 'undefined') {\n          touch.tiltY = 0;\n        }\n\n        if (typeof touch.pointerType === 'undefined') {\n          touch.pointerType = 'touch';\n        }\n\n        if (typeof touch.pointerId === 'undefined') {\n          touch.pointerId = touch.identifier || 0;\n        }\n\n        if (typeof touch.pressure === 'undefined') {\n          touch.pressure = touch.force || 0.5;\n        }\n\n        if (typeof touch.twist === 'undefined') {\n          touch.twist = 0;\n        }\n\n        if (typeof touch.tangentialPressure === 'undefined') {\n          touch.tangentialPressure = 0;\n        } // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n\n\n        if (typeof touch.layerX === 'undefined') {\n          touch.layerX = touch.offsetX = touch.clientX;\n        }\n\n        if (typeof touch.layerY === 'undefined') {\n          touch.layerY = touch.offsetY = touch.clientY;\n        } // mark the touch as normalized, just so that we know we did it\n\n\n        touch.isNormalized = true;\n        normalizedEvents.push(touch);\n      }\n    } // apparently PointerEvent subclasses MouseEvent, so yay\n    else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') {\n          event.isPrimary = true;\n        }\n\n        if (typeof event.width === 'undefined') {\n          event.width = 1;\n        }\n\n        if (typeof event.height === 'undefined') {\n          event.height = 1;\n        }\n\n        if (typeof event.tiltX === 'undefined') {\n          event.tiltX = 0;\n        }\n\n        if (typeof event.tiltY === 'undefined') {\n          event.tiltY = 0;\n        }\n\n        if (typeof event.pointerType === 'undefined') {\n          event.pointerType = 'mouse';\n        }\n\n        if (typeof event.pointerId === 'undefined') {\n          event.pointerId = MOUSE_POINTER_ID;\n        }\n\n        if (typeof event.pressure === 'undefined') {\n          event.pressure = 0.5;\n        }\n\n        if (typeof event.twist === 'undefined') {\n          event.twist = 0;\n        }\n\n        if (typeof event.tangentialPressure === 'undefined') {\n          event.tangentialPressure = 0;\n        } // mark the mouse event as normalized, just so that we know we did it\n\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n    return normalizedEvents;\n  };\n  /**\n   * Destroys the interaction manager\n   *\n   */\n\n\n  InteractionManager.prototype.destroy = function destroy() {\n    this.removeEvents();\n    this.removeTickerListener();\n    this.removeAllListeners();\n    this.renderer = null;\n    this.mouse = null;\n    this.eventData = null;\n    this.interactionDOMElement = null;\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n    this.onPointerOver = null;\n    this.search = null;\n  };\n\n  Object.defineProperties(InteractionManager.prototype, prototypeAccessors);\n  return InteractionManager;\n}(EventEmitter);\n/**\n * This namespace contains a renderer plugin for handling mouse, pointer, and touch events.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @namespace PIXI.interaction\n */\n\n\nexport { InteractionData, InteractionEvent, InteractionManager, InteractionTrackingData, interactiveTarget };","map":{"version":3,"sources":["../src/InteractionData.js","../src/InteractionEvent.js","../src/InteractionTrackingData.js","../src/TreeSearch.js","../src/interactiveTarget.js","../src/InteractionManager.js","../src/index.js"],"names":["prototypeAccessors","let","const","super","displayObject"],"mappings":"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","sourcesContent":["import { Point } from '@pixi/math';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n * @memberof PIXI.interaction\n */\nexport class InteractionData\n{\n    constructor()\n    {\n        /**\n         * This point stores the global coords of where the touch/mouse event happened\n         *\n         * @member {PIXI.Point}\n         */\n        this.global = new Point();\n\n        /**\n         * The target Sprite that was interacted with\n         *\n         * @member {PIXI.Sprite}\n         */\n        this.target = null;\n\n        /**\n         * When passed to an event handler, this will be the original DOM Event that was captured\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n         * @member {MouseEvent|TouchEvent|PointerEvent}\n         */\n        this.originalEvent = null;\n\n        /**\n         * Unique identifier for this interaction\n         *\n         * @member {number}\n         */\n        this.identifier = null;\n\n        /**\n         * Indicates whether or not the pointer device that created the event is the primary pointer.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n         * @type {Boolean}\n         */\n        this.isPrimary = false;\n\n        /**\n         * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n         * @type {number}\n         */\n        this.button = 0;\n\n        /**\n         * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n         * @type {number}\n         */\n        this.buttons = 0;\n\n        /**\n         * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n         * radiusX of TouchEvents will be represented by this value.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n         * @type {number}\n         */\n        this.width = 0;\n\n        /**\n         * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n         * radiusY of TouchEvents will be represented by this value.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n         * @type {number}\n         */\n        this.height = 0;\n\n        /**\n         * The angle, in degrees, between the pointer device and the screen.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n         * @type {number}\n         */\n        this.tiltX = 0;\n\n        /**\n         * The angle, in degrees, between the pointer device and the screen.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n         * @type {number}\n         */\n        this.tiltY = 0;\n\n        /**\n         * The type of pointer that triggered the event.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n         * @type {string}\n         */\n        this.pointerType = null;\n\n        /**\n         * Pressure applied by the pointing device during the event. A Touch's force property\n         * will be represented by this value.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n         * @type {number}\n         */\n        this.pressure = 0;\n\n        /**\n         * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n         * @type {number}\n         */\n        this.rotationAngle = 0;\n\n        /**\n         * Twist of a stylus pointer.\n         * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n         * @type {number}\n         */\n        this.twist = 0;\n\n        /**\n         * Barrel pressure on a stylus pointer.\n         * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n         * @type {number}\n         */\n        this.tangentialPressure = 0;\n    }\n\n    /**\n     * The unique identifier of the pointer. It will be the same as `identifier`.\n     * @readonly\n     * @member {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n     */\n    get pointerId()\n    {\n        return this.identifier;\n    }\n\n    /**\n     * This will return the local coordinates of the specified displayObject for this InteractionData\n     *\n     * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local\n     *  coords off\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative\n     *  to the DisplayObject\n     */\n    getLocalPosition(displayObject, point, globalPos)\n    {\n        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n    }\n\n    /**\n     * Copies properties from normalized event data.\n     *\n     * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n     */\n    copyEvent(event)\n    {\n        // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n        // it with \"false\" on later events when our shim for it on touch events might not be\n        // accurate\n        if (event.isPrimary)\n        {\n            this.isPrimary = true;\n        }\n        this.button = event.button;\n        // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n        // event.which property instead, which conveys the same information.\n        this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;\n        this.width = event.width;\n        this.height = event.height;\n        this.tiltX = event.tiltX;\n        this.tiltY = event.tiltY;\n        this.pointerType = event.pointerType;\n        this.pressure = event.pressure;\n        this.rotationAngle = event.rotationAngle;\n        this.twist = event.twist || 0;\n        this.tangentialPressure = event.tangentialPressure || 0;\n    }\n\n    /**\n     * Resets the data for pooling.\n     */\n    reset()\n    {\n        // isPrimary is the only property that we really need to reset - everything else is\n        // guaranteed to be overwritten\n        this.isPrimary = false;\n    }\n}\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n * @memberof PIXI.interaction\n */\nexport class InteractionEvent\n{\n    constructor()\n    {\n        /**\n         * Whether this event will continue propagating in the tree.\n         *\n         * Remaining events for the {@link stopsPropagatingAt} object\n         * will still be dispatched.\n         *\n         * @member {boolean}\n         */\n        this.stopped = false;\n\n        /**\n         * At which object this event stops propagating.\n         *\n         * @private\n         * @member {PIXI.DisplayObject}\n         */\n        this.stopsPropagatingAt = null;\n\n        /**\n         * Whether we already reached the element we want to\n         * stop propagating at. This is important for delayed events,\n         * where we start over deeper in the tree again.\n         *\n         * @private\n         * @member {boolean}\n         */\n        this.stopPropagationHint = false;\n\n        /**\n         * The object which caused this event to be dispatched.\n         * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.\n         *\n         * @member {PIXI.DisplayObject}\n         */\n        this.target = null;\n\n        /**\n         * The object whose event listenerâ€™s callback is currently being invoked.\n         *\n         * @member {PIXI.DisplayObject}\n         */\n        this.currentTarget = null;\n\n        /**\n         * Type of the event\n         *\n         * @member {string}\n         */\n        this.type = null;\n\n        /**\n         * InteractionData related to this event\n         *\n         * @member {PIXI.interaction.InteractionData}\n         */\n        this.data = null;\n    }\n\n    /**\n     * Prevents event from reaching any objects other than the current object.\n     *\n     */\n    stopPropagation()\n    {\n        this.stopped = true;\n        this.stopPropagationHint = true;\n        this.stopsPropagatingAt = this.currentTarget;\n    }\n\n    /**\n     * Resets the event.\n     */\n    reset()\n    {\n        this.stopped = false;\n        this.stopsPropagatingAt = null;\n        this.stopPropagationHint = false;\n        this.currentTarget = null;\n        this.target = null;\n    }\n}\n","/**\n * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions\n *\n * @class\n * @private\n * @memberof PIXI.interaction\n */\nexport class InteractionTrackingData\n{\n    /**\n     * @param {number} pointerId - Unique pointer id of the event\n     * @private\n     */\n    constructor(pointerId)\n    {\n        this._pointerId = pointerId;\n        this._flags = InteractionTrackingData.FLAGS.NONE;\n    }\n\n    /**\n     *\n     * @private\n     * @param {number} flag - The interaction flag to set\n     * @param {boolean} yn - Should the flag be set or unset\n     */\n    _doSet(flag, yn)\n    {\n        if (yn)\n        {\n            this._flags = this._flags | flag;\n        }\n        else\n        {\n            this._flags = this._flags & (~flag);\n        }\n    }\n\n    /**\n     * Unique pointer id of the event\n     *\n     * @readonly\n     * @private\n     * @member {number}\n     */\n    get pointerId()\n    {\n        return this._pointerId;\n    }\n\n    /**\n     * State of the tracking data, expressed as bit flags\n     *\n     * @private\n     * @member {number}\n     */\n    get flags()\n    {\n        return this._flags;\n    }\n\n    set flags(flags) // eslint-disable-line require-jsdoc\n    {\n        this._flags = flags;\n    }\n\n    /**\n     * Is the tracked event inactive (not over or down)?\n     *\n     * @private\n     * @member {number}\n     */\n    get none()\n    {\n        return this._flags === this.constructor.FLAGS.NONE;\n    }\n\n    /**\n     * Is the tracked event over the DisplayObject?\n     *\n     * @private\n     * @member {boolean}\n     */\n    get over()\n    {\n        return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n    }\n\n    set over(yn) // eslint-disable-line require-jsdoc\n    {\n        this._doSet(this.constructor.FLAGS.OVER, yn);\n    }\n\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     *\n     * @private\n     * @member {boolean}\n     */\n    get rightDown()\n    {\n        return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n    }\n\n    set rightDown(yn) // eslint-disable-line require-jsdoc\n    {\n        this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n    }\n\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     *\n     * @private\n     * @member {boolean}\n     */\n    get leftDown()\n    {\n        return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n    }\n\n    set leftDown(yn) // eslint-disable-line require-jsdoc\n    {\n        this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n    }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2,\n});\n","import { Point } from '@pixi/math';\n\n/**\n * Strategy how to search through stage tree for interactive objects\n *\n * @private\n * @class\n * @memberof PIXI.interaction\n */\nexport class TreeSearch\n{\n    constructor()\n    {\n        this._tempPoint = new Point();\n    }\n\n    /**\n     * Recursive implementation for findHit\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n    recursiveFindHit(interactionEvent, displayObject, func, hitTest, interactive)\n    {\n        if (!displayObject || !displayObject.visible)\n        {\n            return false;\n        }\n\n        const point = interactionEvent.data.global;\n\n        // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n        //\n        // This function will now loop through all objects and then only hit test the objects it HAS\n        // to, not all of them. MUCH faster..\n        // An object will be hit test if the following is true:\n        //\n        // 1: It is interactive.\n        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n        //\n        // As another little optimization once an interactive object has been hit we can carry on\n        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n        // A final optimization is that an object is not hit test directly if a child has already been hit.\n\n        interactive = displayObject.interactive || interactive;\n\n        let hit = false;\n        let interactiveParent = interactive;\n\n        // Flag here can set to false if the event is outside the parents hitArea or mask\n        let hitTestChildren = true;\n\n        // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n        // There is also no longer a need to hitTest children.\n        if (displayObject.hitArea)\n        {\n            if (hitTest)\n            {\n                displayObject.worldTransform.applyInverse(point, this._tempPoint);\n                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y))\n                {\n                    hitTest = false;\n                    hitTestChildren = false;\n                }\n                else\n                {\n                    hit = true;\n                }\n            }\n            interactiveParent = false;\n        }\n        // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n        // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n        // https://github.com/pixijs/pixi.js/issues/5135\n        else if (displayObject._mask)\n        {\n            if (hitTest)\n            {\n                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point)))\n                {\n                    hitTest = false;\n                }\n            }\n        }\n\n        // ** FREE TIP **! If an object is not interactive or has no buttons in it\n        // (such as a game scene!) set interactiveChildren to false for that displayObject.\n        // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\n        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children)\n        {\n            const children = displayObject.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i];\n\n                // time to get recursive.. if this function will return if something is hit..\n                const childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n\n                if (childHit)\n                {\n                    // its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (!child.parent)\n                    {\n                        continue;\n                    }\n\n                    // we no longer need to hit test any more objects in this container as we we\n                    // now know the parent has been hit\n                    interactiveParent = false;\n\n                    // If the child is interactive , that means that the object hit was actually\n                    // interactive and not just the child of an interactive object.\n                    // This means we no longer need to hit test anything else. We still need to run\n                    // through all objects, but we don't need to perform any hit tests.\n\n                    if (childHit)\n                    {\n                        if (interactionEvent.target)\n                        {\n                            hitTest = false;\n                        }\n                        hit = true;\n                    }\n                }\n            }\n        }\n\n        // no point running this if the item is not interactive or does not have an interactive parent.\n        if (interactive)\n        {\n            // if we are hit testing (as in we have no hit any objects yet)\n            // We also don't need to worry about hit testing if once of the displayObjects children\n            // has already been hit - but only if it was interactive, otherwise we need to keep\n            // looking for an interactive child, just in case we hit one\n            if (hitTest && !interactionEvent.target)\n            {\n                // already tested against hitArea if it is defined\n                if (!displayObject.hitArea && displayObject.containsPoint)\n                {\n                    if (displayObject.containsPoint(point))\n                    {\n                        hit = true;\n                    }\n                }\n            }\n\n            if (displayObject.interactive)\n            {\n                if (hit && !interactionEvent.target)\n                {\n                    interactionEvent.target = displayObject;\n                }\n\n                if (func)\n                {\n                    func(interactionEvent, displayObject, !!hit);\n                }\n            }\n        }\n\n        return hit;\n    }\n\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n    findHit(interactionEvent, displayObject, func, hitTest)\n    {\n        this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n    }\n}\n","/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n *\n * @interface IHitArea\n * @memberof PIXI\n */\n\n/**\n * Checks whether the x and y coordinates given are contained within this area\n *\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this area\n */\n\n/**\n * Default property values of interactive objects\n * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties\n *\n * @private\n * @name interactiveTarget\n * @type {Object}\n * @memberof PIXI.interaction\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interaction.interactiveTarget\n *      );\n */\nexport const interactiveTarget = {\n\n    /**\n     * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n     * events will not be emitted unless `interactive` is set to `true`.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.on('tap', (event) => {\n     *    //handle event\n     * });\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */\n    interactive: false,\n\n    /**\n     * Determines if the children to the displayObject can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     *\n     * @member {boolean}\n     * @memberof PIXI.Container#\n     */\n    interactiveChildren: true,\n\n    /**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n     * @member {PIXI.IHitArea}\n     * @memberof PIXI.DisplayObject#\n     */\n    hitArea: null,\n\n    /**\n     * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n     * Setting this changes the 'cursor' property to `'pointer'`.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.buttonMode = true;\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */\n    get buttonMode()\n    {\n        return this.cursor === 'pointer';\n    },\n    set buttonMode(value)\n    {\n        if (value)\n        {\n            this.cursor = 'pointer';\n        }\n        else if (this.cursor === 'pointer')\n        {\n            this.cursor = null;\n        }\n    },\n\n    /**\n     * This defines what cursor mode is used when the mouse cursor\n     * is hovered over the displayObject.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.cursor = 'wait';\n     * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n     *\n     * @member {string}\n     * @memberof PIXI.DisplayObject#\n     */\n    cursor: null,\n\n    /**\n     * Internal set of all active pointers, by identifier\n     *\n     * @member {Map<number, InteractionTrackingData>}\n     * @memberof PIXI.DisplayObject#\n     * @private\n     */\n    get trackedPointers()\n    {\n        if (this._trackedPointers === undefined) this._trackedPointers = {};\n\n        return this._trackedPointers;\n    },\n\n    /**\n     * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n     *\n     * @private\n     * @type {Map<number, InteractionTrackingData>}\n     */\n    _trackedPointers: undefined,\n};\n","import { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { DisplayObject } from '@pixi/display';\nimport { InteractionData } from './InteractionData';\nimport { InteractionEvent } from './InteractionEvent';\nimport { InteractionTrackingData } from './InteractionTrackingData';\nimport { TreeSearch } from './TreeSearch';\nimport { EventEmitter } from '@pixi/utils';\nimport { interactiveTarget } from './interactiveTarget';\n\n// Mix interactiveTarget into DisplayObject.prototype,\n// after deprecation has been handled\nDisplayObject.mixin(interactiveTarget);\n\nconst MOUSE_POINTER_ID = 1;\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n    target: null,\n    data: {\n        global: null,\n    },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI.interaction\n */\nexport class InteractionManager extends EventEmitter\n{\n    /**\n     * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer\n     * @param {object} [options] - The options for the manager.\n     * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.\n     * @param {number} [options.interactionFrequency=10] - Maximum requency (ms) at pointer over/out states will be checked.\n     * @param {number} [options.useSystemTicker=true] - Whether to add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     */\n    constructor(renderer, options)\n    {\n        super();\n\n        options = options || {};\n\n        /**\n         * The renderer this interaction manager works for.\n         *\n         * @member {PIXI.AbstractRenderer}\n         */\n        this.renderer = renderer;\n\n        /**\n         * Should default browser actions automatically be prevented.\n         * Does not apply to pointer events for backwards compatibility\n         * preventDefault on pointer events stops mouse events from firing\n         * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n\n        /**\n         * Maximum requency in milliseconds at which pointer over/out states will be checked by {@link tickerUpdate}.\n         *\n         * @member {number}\n         * @default 10\n         */\n        this.interactionFrequency = options.interactionFrequency || 10;\n\n        /**\n         * The mouse data\n         *\n         * @member {PIXI.interaction.InteractionData}\n         */\n        this.mouse = new InteractionData();\n        this.mouse.identifier = MOUSE_POINTER_ID;\n\n        // setting the mouse to start off far off screen will mean that mouse over does\n        //  not get called before we even move the mouse.\n        this.mouse.global.set(-999999);\n\n        /**\n         * Actively tracked InteractionData\n         *\n         * @private\n         * @member {Object.<number,PIXI.interaction.InteractionData>}\n         */\n        this.activeInteractionData = {};\n        this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n        /**\n         * Pool of unused InteractionData\n         *\n         * @private\n         * @member {PIXI.interaction.InteractionData[]}\n         */\n        this.interactionDataPool = [];\n\n        /**\n         * An event data object to handle all the event tracking/dispatching\n         *\n         * @member {object}\n         */\n        this.eventData = new InteractionEvent();\n\n        /**\n         * The DOM element to bind to.\n         *\n         * @protected\n         * @member {HTMLElement}\n         */\n        this.interactionDOMElement = null;\n\n        /**\n         * This property determines if mousemove and touchmove events are fired only when the cursor\n         * is over the object.\n         * Setting to true will make things work more in line with how the DOM version works.\n         * Setting to false can make things easier for things like dragging\n         * It is currently set to false as this is how PixiJS used to work. This will be set to true in\n         * future versions of pixi.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.moveWhenInside = false;\n\n        /**\n         * Have events been attached to the dom element?\n         *\n         * @protected\n         * @member {boolean}\n         */\n        this.eventsAdded = false;\n\n        /**\n         * Has the system ticker been added?\n         *\n         * @protected\n         * @member {boolean}\n         */\n        this.tickerAdded = false;\n\n        /**\n         * Is the mouse hovering over the renderer?\n         *\n         * @protected\n         * @member {boolean}\n         */\n        this.mouseOverRenderer = false;\n\n        /**\n         * Does the device support touch events\n         * https://www.w3.org/TR/touch-events/\n         *\n         * @readonly\n         * @member {boolean}\n         */\n        this.supportsTouchEvents = 'ontouchstart' in window;\n\n        /**\n         * Does the device support pointer events\n         * https://www.w3.org/Submission/pointer-events/\n         *\n         * @readonly\n         * @member {boolean}\n         */\n        this.supportsPointerEvents = !!window.PointerEvent;\n\n        // this will make it so that you don't have to call bind all the time\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.processPointerUp = this.processPointerUp.bind(this);\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerCancel = this.onPointerCancel.bind(this);\n        this.processPointerCancel = this.processPointerCancel.bind(this);\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.processPointerDown = this.processPointerDown.bind(this);\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.processPointerMove = this.processPointerMove.bind(this);\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerOut = this.onPointerOut.bind(this);\n        this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n        /**\n         * @private\n         * @member {Function}\n         */\n        this.onPointerOver = this.onPointerOver.bind(this);\n\n        /**\n         * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n         * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n         * and functions are called instead of changing the CSS.\n         * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n         * @member {Object.<string, Object>}\n         */\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        /**\n         * The mode of the cursor that is being used.\n         * The value of this is a key from the cursorStyles dictionary.\n         *\n         * @member {string}\n         */\n        this.currentCursorMode = null;\n\n        /**\n         * Internal cached let.\n         *\n         * @private\n         * @member {string}\n         */\n        this.cursor = null;\n\n        /**\n         * The current resolution / device pixel ratio.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = 1;\n\n        /**\n         * Delayed pointer events. Used to guarantee correct ordering of over/out events.\n         *\n         * @private\n         * @member {Array}\n         */\n        this.delayedEvents = [];\n\n        /**\n         * TreeSearch component that is used to hitTest stage tree\n         *\n         * @private\n         * @member {PIXI.interaction.TreeSearch}\n         */\n        this.search = new TreeSearch();\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n         * object.\n         *\n         * @event PIXI.interaction.InteractionManager#mousedown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#rightdown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object.\n         *\n         * @event PIXI.interaction.InteractionManager#mouseup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#rightup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#click\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#rightclick\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.\n         *\n         * @event PIXI.interaction.InteractionManager#mouseupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.\n         *\n         * @event PIXI.interaction.InteractionManager#rightupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object\n         *\n         * @event PIXI.interaction.InteractionManager#mousemove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object\n         *\n         * @event PIXI.interaction.InteractionManager#mouseover\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object\n         *\n         * @event PIXI.interaction.InteractionManager#mouseout\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed on the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#pointerdown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released over the display object.\n         * Not always fired when some buttons are held down while others are released. In those cases,\n         * use [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown} and\n         * [mouseup]{@link PIXI.interaction.InteractionManager#event:mouseup} instead.\n         *\n         * @event PIXI.interaction.InteractionManager#pointerup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a pointer event\n         *\n         * @event PIXI.interaction.InteractionManager#pointercancel\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#pointertap\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.\n         *\n         * @event PIXI.interaction.InteractionManager#pointerupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved while over the display object\n         *\n         * @event PIXI.interaction.InteractionManager#pointermove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved onto the display object\n         *\n         * @event PIXI.interaction.InteractionManager#pointerover\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved off the display object\n         *\n         * @event PIXI.interaction.InteractionManager#pointerout\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed on the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#touchstart\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed from the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#touchend\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a touch\n         *\n         * @event PIXI.interaction.InteractionManager#touchcancel\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed and removed from the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#tap\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.\n         *\n         * @event PIXI.interaction.InteractionManager#touchendoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is moved along the display object.\n         *\n         * @event PIXI.interaction.InteractionManager#touchmove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mousedown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#rightdown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mouseup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#rightup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#click\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#rightclick\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mouseupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#rightupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mousemove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mouseover\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#mouseout\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointerdown\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointerup\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a pointer event.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointercancel\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointertap\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointerupoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointermove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointerover\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#pointerout\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#touchstart\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#touchend\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a touch.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#touchcancel\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed and removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#tap\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#touchendoutside\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is moved along the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * @event PIXI.DisplayObject#touchmove\n         * @param {PIXI.interaction.InteractionEvent} event - Interaction event\n         */\n\n        this._useSystemTicker = options.useSystemTicker !== undefined ? options.useSystemTicker : true;\n\n        this.setTargetElement(this.renderer.view, this.renderer.resolution);\n    }\n\n    /**\n     * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    get useSystemTicker()\n    {\n        return this._useSystemTicker;\n    }\n    set useSystemTicker(useSystemTicker)\n    {\n        this._useSystemTicker = useSystemTicker;\n\n        if (useSystemTicker)\n        {\n            this.addTickerListener();\n        }\n        else\n        {\n            this.removeTickerListener();\n        }\n    }\n\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.\n     * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return {PIXI.DisplayObject} The hit display object, if any.\n     */\n    hitTest(globalPoint, root)\n    {\n        // clear the target for our hit test\n        hitTestEvent.target = null;\n        // assign the global point\n        hitTestEvent.data.global = globalPoint;\n        // ensure safety of the root\n        if (!root)\n        {\n            root = this.renderer._lastObjectRendered;\n        }\n        // run the hit test\n        this.processInteractive(hitTestEvent, root, null, true);\n        // return our found object - it'll be null if we didn't hit anything\n\n        return hitTestEvent.target;\n    }\n\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLElement} element - the DOM element which will receive mouse and touch events.\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).\n     */\n    setTargetElement(element, resolution = 1)\n    {\n        this.removeTickerListener();\n\n        this.removeEvents();\n\n        this.interactionDOMElement = element;\n\n        this.resolution = resolution;\n\n        this.addEvents();\n\n        this.addTickerListener();\n    }\n\n    /**\n     * Add the ticker listener\n     *\n     * @private\n     */\n    addTickerListener()\n    {\n        if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker)\n        {\n            return;\n        }\n\n        Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this.tickerAdded = true;\n    }\n\n    /**\n     * Remove the ticker listener\n     *\n     * @private\n     */\n    removeTickerListener()\n    {\n        if (!this.tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this.tickerUpdate, this);\n\n        this.tickerAdded = false;\n    }\n\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n    addEvents()\n    {\n        if (this.eventsAdded || !this.interactionDOMElement)\n        {\n            return;\n        }\n\n        if (window.navigator.msPointerEnabled)\n        {\n            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n            this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            this.interactionDOMElement.style['touch-action'] = 'none';\n        }\n\n        /**\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            window.document.addEventListener('pointermove', this.onPointerMove, true);\n            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n            window.addEventListener('pointercancel', this.onPointerCancel, true);\n            window.addEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            window.document.addEventListener('mousemove', this.onPointerMove, true);\n            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n            window.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents)\n        {\n            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.eventsAdded = true;\n    }\n\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n    removeEvents()\n    {\n        if (!this.eventsAdded || !this.interactionDOMElement)\n        {\n            return;\n        }\n\n        if (window.navigator.msPointerEnabled)\n        {\n            this.interactionDOMElement.style['-ms-content-zooming'] = '';\n            this.interactionDOMElement.style['-ms-touch-action'] = '';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            this.interactionDOMElement.style['touch-action'] = '';\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            window.document.removeEventListener('pointermove', this.onPointerMove, true);\n            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n            window.removeEventListener('pointercancel', this.onPointerCancel, true);\n            window.removeEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            window.document.removeEventListener('mousemove', this.onPointerMove, true);\n            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n            window.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        if (this.supportsTouchEvents)\n        {\n            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.interactionDOMElement = null;\n\n        this.eventsAdded = false;\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n     *\n     * @param {number} deltaTime - time delta since the last call\n     */\n    tickerUpdate(deltaTime)\n    {\n        this._deltaTime += deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this.update();\n    }\n\n    /**\n     * Updates the state of interactive objects.\n     */\n    update()\n    {\n        if (!this.interactionDOMElement)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this.didMove)\n        {\n            this.didMove = false;\n\n            return;\n        }\n\n        this.cursor = null;\n\n        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n        // but there was a scenario of a display object moving under a static mouse cursor.\n        // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\n        for (const k in this.activeInteractionData)\n        {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.activeInteractionData.hasOwnProperty(k))\n            {\n                const interactionData = this.activeInteractionData[k];\n\n                if (interactionData.originalEvent && interactionData.pointerType !== 'touch')\n                {\n                    const interactionEvent = this.configureInteractionEventForDOMEvent(\n                        this.eventData,\n                        interactionData.originalEvent,\n                        interactionData\n                    );\n\n                    this.processInteractive(\n                        interactionEvent,\n                        this.renderer._lastObjectRendered,\n                        this.processPointerOverOut,\n                        true\n                    );\n                }\n            }\n        }\n\n        this.setCursorMode(this.cursor);\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    setCursorMode(mode)\n    {\n        mode = mode || 'default';\n        // if the mode didn't actually change, bail early\n        if (this.currentCursorMode === mode)\n        {\n            return;\n        }\n        this.currentCursorMode = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    this.interactionDOMElement.style.cursor = style;\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    Object.assign(this.interactionDOMElement.style, style);\n                    break;\n            }\n        }\n        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.interactionDOMElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n    dispatchEvent(displayObject, eventString, eventData)\n    {\n        // Even if the event was stopped, at least dispatch any remaining events\n        // for the same display object.\n        if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt)\n        {\n            eventData.currentTarget = displayObject;\n            eventData.type = eventString;\n\n            displayObject.emit(eventString, eventData);\n\n            if (displayObject[eventString])\n            {\n                displayObject[eventString](eventData);\n            }\n        }\n    }\n\n    /**\n     * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n     * ordering of over/out events.\n     *\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n    delayDispatchEvent(displayObject, eventString, eventData)\n    {\n        this.delayedEvents.push({ displayObject, eventString, eventData });\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {PIXI.Point} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    mapPositionToPoint(point, x, y)\n    {\n        let rect;\n\n        // IE 11 fix\n        if (!this.interactionDOMElement.parentElement)\n        {\n            rect = { x: 0, y: 0, width: 0, height: 0 };\n        }\n        else\n        {\n            rect = this.interactionDOMElement.getBoundingClientRect();\n        }\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @protected\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - indicates whether we want to calculate hits\n     *  or just iterate through all interactive objects\n     */\n    processInteractive(interactionEvent, displayObject, func, hitTest)\n    {\n        const hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n\n        const delayedEvents = this.delayedEvents;\n\n        if (!delayedEvents.length)\n        {\n            return hit;\n        }\n        // Reset the propagation hint, because we start deeper in the tree again.\n        interactionEvent.stopPropagationHint = false;\n\n        const delayedLen = delayedEvents.length;\n\n        this.delayedEvents = [];\n\n        for (let i = 0; i < delayedLen; i++)\n        {\n            const { displayObject, eventString, eventData } = delayedEvents[i];\n\n            // When we reach the object we wanted to stop propagating at,\n            // set the propagation hint.\n            if (eventData.stopsPropagatingAt === displayObject)\n            {\n                eventData.stopPropagationHint = true;\n            }\n\n            this.dispatchEvent(displayObject, eventString, eventData);\n        }\n\n        return hit;\n    }\n\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n    onPointerDown(originalEvent)\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        /**\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && events[0].isNormalized)\n        {\n            const cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);\n\n            if (cancelable)\n            {\n                originalEvent.preventDefault();\n            }\n        }\n\n        const eventLen = events.length;\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);\n\n            this.emit('pointerdown', interactionEvent);\n            if (event.pointerType === 'touch')\n            {\n                this.emit('touchstart', interactionEvent);\n            }\n            // emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\n            else if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n            {\n                const isRightButton = event.button === 2;\n\n                this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n            }\n        }\n    }\n\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n    processPointerDown(interactionEvent, displayObject, hit)\n    {\n        const data = interactionEvent.data;\n        const id = interactionEvent.data.identifier;\n\n        if (hit)\n        {\n            if (!displayObject.trackedPointers[id])\n            {\n                displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n            }\n            this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);\n\n            if (data.pointerType === 'touch')\n            {\n                this.dispatchEvent(displayObject, 'touchstart', interactionEvent);\n            }\n            else if (data.pointerType === 'mouse' || data.pointerType === 'pen')\n            {\n                const isRightButton = data.button === 2;\n\n                if (isRightButton)\n                {\n                    displayObject.trackedPointers[id].rightDown = true;\n                }\n                else\n                {\n                    displayObject.trackedPointers[id].leftDown = true;\n                }\n\n                this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n    onPointerComplete(originalEvent, cancelled, func)\n    {\n        const events = this.normalizeToPointerData(originalEvent);\n\n        const eventLen = events.length;\n\n        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n        // in all cases (unless it was a pointercancel)\n        const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            // perform hit testing for events targeting our canvas or cancel events\n            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);\n\n            this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n            if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n            {\n                const isRightButton = event.button === 2;\n\n                this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n            }\n            else if (event.pointerType === 'touch')\n            {\n                this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n                this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n    onPointerCancel(event)\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n        this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n     */\n    processPointerCancel(interactionEvent, displayObject)\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        if (displayObject.trackedPointers[id] !== undefined)\n        {\n            delete displayObject.trackedPointers[id];\n            this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);\n\n            if (data.pointerType === 'touch')\n            {\n                this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n    onPointerUp(event)\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n        this.onPointerComplete(event, false, this.processPointerUp);\n    }\n\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n    processPointerUp(interactionEvent, displayObject, hit)\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        const trackingData = displayObject.trackedPointers[id];\n\n        const isTouch = data.pointerType === 'touch';\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n        // need to track mouse down status in the mouse block so that we can emit\n        // event in a later block\n        let isMouseTap = false;\n\n        // Mouse only\n        if (isMouse)\n        {\n            const isRightButton = data.button === 2;\n\n            const flags = InteractionTrackingData.FLAGS;\n\n            const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n            const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n            if (hit)\n            {\n                this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n                if (isDown)\n                {\n                    this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);\n                    // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\n                    isMouseTap = true;\n                }\n            }\n            else if (isDown)\n            {\n                this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n            }\n            // update the down state of the tracking data\n            if (trackingData)\n            {\n                if (isRightButton)\n                {\n                    trackingData.rightDown = false;\n                }\n                else\n                {\n                    trackingData.leftDown = false;\n                }\n            }\n        }\n\n        // Pointers and Touches, and Mouse\n        if (hit)\n        {\n            this.dispatchEvent(displayObject, 'pointerup', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchend', interactionEvent);\n\n            if (trackingData)\n            {\n                // emit pointertap if not a mouse, or if the mouse block decided it was a tap\n                if (!isMouse || isMouseTap)\n                {\n                    this.dispatchEvent(displayObject, 'pointertap', interactionEvent);\n                }\n                if (isTouch)\n                {\n                    this.dispatchEvent(displayObject, 'tap', interactionEvent);\n                    // touches are no longer over (if they ever were) when we get the touchend\n                    // so we should ensure that we don't keep pretending that they are\n                    trackingData.over = false;\n                }\n            }\n        }\n        else if (trackingData)\n        {\n            this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);\n        }\n        // Only remove the tracking data if there is no over/down state still associated with it\n        if (trackingData && trackingData.none)\n        {\n            delete displayObject.trackedPointers[id];\n        }\n    }\n\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n    onPointerMove(originalEvent)\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen')\n        {\n            this.didMove = true;\n\n            this.cursor = null;\n        }\n\n        const eventLen = events.length;\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, true);\n\n            this.emit('pointermove', interactionEvent);\n            if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n            if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n        }\n\n        if (events[0].pointerType === 'mouse')\n        {\n            this.setCursorMode(this.cursor);\n\n            // TODO BUG for parents interactive object (border order issue)\n        }\n    }\n\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n    processPointerMove(interactionEvent, displayObject, hit)\n    {\n        const data = interactionEvent.data;\n\n        const isTouch = data.pointerType === 'touch';\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n        if (isMouse)\n        {\n            this.processPointerOverOut(interactionEvent, displayObject, hit);\n        }\n\n        if (!this.moveWhenInside || hit)\n        {\n            this.dispatchEvent(displayObject, 'pointermove', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchmove', interactionEvent);\n            if (isMouse) this.dispatchEvent(displayObject, 'mousemove', interactionEvent);\n        }\n    }\n\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n    onPointerOut(originalEvent)\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOut, so events will always be length 1\n        const event = events[0];\n\n        if (event.pointerType === 'mouse')\n        {\n            this.mouseOverRenderer = false;\n            this.setCursorMode(null);\n        }\n\n        const interactionData = this.getInteractionDataForPointerId(event);\n\n        const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n        interactionEvent.data.originalEvent = event;\n\n        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);\n\n        this.emit('pointerout', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n        {\n            this.emit('mouseout', interactionEvent);\n        }\n        else\n        {\n            // we can get touchleave events after touchend, so we want to make sure we don't\n            // introduce memory leaks\n            this.releaseInteractionDataForPointerId(interactionData.identifier);\n        }\n    }\n\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n    processPointerOverOut(interactionEvent, displayObject, hit)\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n        let trackingData = displayObject.trackedPointers[id];\n\n        // if we just moused over the display object, then we need to track that state\n        if (hit && !trackingData)\n        {\n            trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        if (trackingData === undefined) return;\n\n        if (hit && this.mouseOverRenderer)\n        {\n            if (!trackingData.over)\n            {\n                trackingData.over = true;\n                this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);\n                if (isMouse)\n                {\n                    this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);\n                }\n            }\n\n            // only change the cursor if it has not already been changed (by something deeper in the\n            // display tree)\n            if (isMouse && this.cursor === null)\n            {\n                this.cursor = displayObject.cursor;\n            }\n        }\n        else if (trackingData.over)\n        {\n            trackingData.over = false;\n            this.dispatchEvent(displayObject, 'pointerout', this.eventData);\n            if (isMouse)\n            {\n                this.dispatchEvent(displayObject, 'mouseout', interactionEvent);\n            }\n            // if there is no mouse down information for the pointer, then it is safe to delete\n            if (trackingData.none)\n            {\n                delete displayObject.trackedPointers[id];\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n    onPointerOver(originalEvent)\n    {\n        const events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOver, so events will always be length 1\n        const event = events[0];\n\n        const interactionData = this.getInteractionDataForPointerId(event);\n\n        const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n        interactionEvent.data.originalEvent = event;\n\n        if (event.pointerType === 'mouse')\n        {\n            this.mouseOverRenderer = true;\n        }\n\n        this.emit('pointerover', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n        {\n            this.emit('mouseover', interactionEvent);\n        }\n    }\n\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier\n     */\n    getInteractionDataForPointerId(event)\n    {\n        const pointerId = event.pointerId;\n\n        let interactionData;\n\n        if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse')\n        {\n            interactionData = this.mouse;\n        }\n        else if (this.activeInteractionData[pointerId])\n        {\n            interactionData = this.activeInteractionData[pointerId];\n        }\n        else\n        {\n            interactionData = this.interactionDataPool.pop() || new InteractionData();\n            interactionData.identifier = pointerId;\n            this.activeInteractionData[pointerId] = interactionData;\n        }\n        // copy properties from the event, so that we can make sure that touch/pointer specific\n        // data is available\n        interactionData.copyEvent(event);\n\n        return interactionData;\n    }\n\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n    releaseInteractionDataForPointerId(pointerId)\n    {\n        const interactionData = this.activeInteractionData[pointerId];\n\n        if (interactionData)\n        {\n            delete this.activeInteractionData[pointerId];\n            interactionData.reset();\n            this.interactionDataPool.push(interactionData);\n        }\n    }\n\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in\n     */\n    configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData)\n    {\n        interactionEvent.data = interactionData;\n\n        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n        // Not really sure why this is happening, but it's how a previous version handled things\n        if (pointerEvent.pointerType === 'touch')\n        {\n            pointerEvent.globalX = interactionData.global.x;\n            pointerEvent.globalY = interactionData.global.y;\n        }\n\n        interactionData.originalEvent = pointerEvent;\n        interactionEvent.reset();\n\n        return interactionEvent;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    normalizeToPointerData(event)\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i];\n\n                if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent)))\n        {\n            if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n            if (typeof event.width === 'undefined') event.width = 1;\n            if (typeof event.height === 'undefined') event.height = 1;\n            if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n            if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n            if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n            if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n            if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n            if (typeof event.twist === 'undefined') event.twist = 0;\n            if (typeof event.tangentialPressure === 'undefined') event.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            event.isNormalized = true;\n\n            normalizedEvents.push(event);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents;\n    }\n\n    /**\n     * Destroys the interaction manager\n     *\n     */\n    destroy()\n    {\n        this.removeEvents();\n\n        this.removeTickerListener();\n\n        this.removeAllListeners();\n\n        this.renderer = null;\n\n        this.mouse = null;\n\n        this.eventData = null;\n\n        this.interactionDOMElement = null;\n\n        this.onPointerDown = null;\n        this.processPointerDown = null;\n\n        this.onPointerUp = null;\n        this.processPointerUp = null;\n\n        this.onPointerCancel = null;\n        this.processPointerCancel = null;\n\n        this.onPointerMove = null;\n        this.processPointerMove = null;\n\n        this.onPointerOut = null;\n        this.processPointerOverOut = null;\n\n        this.onPointerOver = null;\n\n        this.search = null;\n    }\n}\n","/**\n * This namespace contains a renderer plugin for handling mouse, pointer, and touch events.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @namespace PIXI.interaction\n */\nexport * from './InteractionData';\nexport * from './InteractionManager';\nexport * from './interactiveTarget';\nexport * from './InteractionTrackingData';\nexport * from './InteractionEvent';\n"]},"metadata":{},"sourceType":"module"}